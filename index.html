<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualization</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-variant: small-caps;
        }
        body {
            background: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        #webgl-canvas { z-index: 1; cursor: pointer; }
        #ripples-canvas { z-index: 2; pointer-events: none; }
        .ui-panel {
            position: absolute;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: rgba(0, 0, 0, .7);
            border-radius: 12px;
            border: 1px solid rgba(255, 120, 50, .3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, .5);
            z-index: 10;
            padding: 15px;
            color: #eee;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        #theme-selector {
            top: 20px;
            right: 20px;
            max-width: 180px;
        }
        #theme-selector-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 10px;
        }
        #formation-label {
            font-size: 13px;
            margin-top: 10px;
            color: rgba(255, 120, 50, .9);
        }
        .theme-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            justify-items: center;
        }
        .theme-button {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, .3);
            cursor: pointer;
            transition: transform .2s, border-color .2s;
            outline: none;
            overflow: hidden;
        }
        .theme-button:hover, .theme-button:focus {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, .7);
        }
        .theme-button.active {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, .9);
            box-shadow: 0 0 10px rgba(255, 200, 150, .6);
        }
        #theme-1 { background: linear-gradient(45deg, #4F46E5, #7C3AED, #C026D3, #DB2777); }
        #theme-2 { background: linear-gradient(45deg, #F59E0B, #F97316, #DC2626, #7F1D1D); }
        #theme-3 { background: linear-gradient(45deg, #EC4899, #8B5CF6, #6366F1, #3B82F6); }
        #theme-4 { background: linear-gradient(45deg, #10B981, #A3E635, #FACC15, #FB923C); }
        #density-controls {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }
        .density-label {
            font-size: 13px;
            display: flex;
            justify-content: space-between;
        }
        .density-slider {
            width: 100%;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 120, 50, .3);
            outline: none;
            cursor: pointer;
        }
        .density-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 120, 50, .8);
            cursor: pointer;
            transition: transform .1s, background .1s;
        }
        .density-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 120, 50, .8);
            cursor: pointer;
            border: none;
            transition: transform .1s, background .1s;
        }
        .density-slider::-webkit-slider-thumb:hover { transform: scale(1.1); background: rgba(255, 140, 50, 1); }
        .density-slider::-moz-range-thumb:hover { transform: scale(1.1); background: rgba(255, 140, 50, 1); }
        .legend {
            pointer-events: none;
            position: absolute;
            color: white;
            font-family: 'Orbitron', sans-serif;
            z-index: 10;
        }
        .legend p {
            user-select: none;
            top: 10px;
            left: 25px;
            position: relative;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 5px;
            font-size: 12px;
        }
        .legend p.vert {
            left: 5px;
            margin-top: 10px;
            writing-mode: vertical-lr;
            text-orientation: upright;
        }
        @media (max-width: 640px) {
            #theme-selector {
                top: auto;
                bottom: 20px;
                right: 10px;
                left: auto;
                max-width: 140px;
                padding: 10px;
            }
            #theme-selector-title, #formation-label {
                font-size: 14px;
            }
            .theme-button {
                width: 30px;
                height: 30px;
            }
            .density-label { font-size: 12px; }
        }
        @media (max-width: 400px) {
            #theme-selector {
                width: calc(100% - 20px);
                left: 10px;
                right: 10px;
                bottom: 20px;
            }
            .theme-grid {
                grid-template-columns: repeat(4, 1fr);
            }
            #density-controls {
                width: 80%;
                margin-top: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="theme-selector" class="ui-panel">
        <div id="theme-selector-title">Visual Theme</div>
        <div class="theme-grid">
            <button class="theme-button active" id="theme-1" data-theme="0" aria-label="Theme 1"></button>
            <button class="theme-button" id="theme-2" data-theme="1" aria-label="Theme 2"></button>
            <button class="theme-button" id="theme-3" data-theme="2" aria-label="Theme 3"></button>
            <button class="theme-button" id="theme-4" data-theme="3" aria-label="Theme 4"></button>
        </div>
        <div id="density-controls">
            <div class="density-label"><span>Density</span><span id="density-value">100%</span></div>
            <input type="range" min="20" max="100" value="100" class="density-slider" id="density-slider" aria-label="Network Density">
        </div>
        <div id="formation-label">Cube</div>
    </div>
    <div class="legend">
        <p>Pitch</p>
        <p class="vert">Volume</p>
    </div>
    <canvas id="webgl-canvas"></canvas>
    <canvas id="ripples-canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pizzicato/0.6.4/Pizzicato.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // Local easing replacement (avoid external dependency)
        const easingUtils = {
            easeInOutCubic: (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2)
        };

        const config = {
            activePaletteIndex: 0,
            currentFormation: 0,
            numFormations: 7,
            densityFactor: 1,
            isTransitioning: false,
            transitionProgress: 0,
            transitionDuration: 3.5,
            targetFormation: null,
            formationNames: ['Cube', 'Spiral', 'Double Helix', 'Mandalas', 'Black Hole', 'Heart', 'Moving Spiral'],
            breatheScale: 1
        };

        const colorPalettes = [
            [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)],
            [new THREE.Color(0xF59E0B), new THREE.Color(0xF97316), new THREE.Color(0xDC2626), new THREE.Color(0x7F1D1D), new THREE.Color(0xFBBF24)],
            [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)],
            [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)]
        ];

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
        camera.position.set(0, 5, 25);

        const webglCanvas = document.getElementById('webgl-canvas');
        const overlayCanvas = document.getElementById('ripples-canvas');
        const ctx = overlayCanvas.getContext('2d');

        const renderer = new THREE.WebGLRenderer({ canvas: webglCanvas, antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000);
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const render = {
            width: window.innerWidth,
            hWidth: window.innerWidth * 0.5,
            height: window.innerHeight,
            hHeight: window.innerHeight * 0.5,
            dpi: window.devicePixelRatio
        };
        overlayCanvas.width = render.width * render.dpi;
        overlayCanvas.height = render.height * render.dpi;

        function createStarfield() {
            const count = 15000, pos = [], colors = [], velocities = [];
            const palette = colorPalettes[config.activePaletteIndex];
            for (let i = 0; i < count; i++) {
                const r = THREE.MathUtils.randFloat(50, 200);
                const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
                const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                const color = palette[Math.floor(Math.random() * palette.length)].clone();
                color.offsetHSL(
                    THREE.MathUtils.randFloatSpread(0.15),
                    THREE.MathUtils.randFloatSpread(0.3),
                    THREE.MathUtils.randFloatSpread(0.3)
                );
                colors.push(color.r, color.g, color.b);
                velocities.push(
                    THREE.MathUtils.randFloatSpread(0.1),
                    THREE.MathUtils.randFloatSpread(0.1),
                    THREE.MathUtils.randFloatSpread(0.1)
                );
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            const mat = new THREE.PointsMaterial({
                size: 0.25,
                sizeAttenuation: true,
                depthWrite: false,
                opacity: 0.85,
                transparent: true,
                vertexColors: true
            });
            return { points: new THREE.Points(geo, mat), shootingStars: [] };
        }

        const starfield = createStarfield();
        scene.add(starfield.points);

        function createShootingStar() {
            const pos = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(200),
                THREE.MathUtils.randFloatSpread(200),
                THREE.MathUtils.randFloatSpread(200)
            );
            const dir = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(1),
                THREE.MathUtils.randFloatSpread(1),
                THREE.MathUtils.randFloatSpread(1)
            ).normalize();
            const geo = new THREE.BufferGeometry();
            const positions = [pos.x, pos.y, pos.z, pos.x + dir.x * 4, pos.y + dir.y * 4, pos.z + dir.z * 4];
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const palette = colorPalettes[config.activePaletteIndex];
            const color = palette[Math.floor(Math.random() * palette.length)].clone();
            const mat = new THREE.LineBasicMaterial({ color, linewidth: 4, transparent: true, opacity: 1 });
            const line = new THREE.Line(geo, mat);
            return { line, direction: dir, life: 2.5 };
        }

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 5;
        controls.maxDistance = 150;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;
        controls.enablePan = false;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.6, 0.75);
        composer.addPass(bloomPass);
        const filmPass = new FilmPass(0.5, 0.7, 2048, false);
        composer.addPass(filmPass);
        composer.addPass(new OutputPass());

        class Wave {
            constructor(cx, cy) {
                this.ripples = [];
                this.rippleSpeed = 15;
                this.rippleCount = 5;
                this.epicenterX = cx;
                this.epicenterY = cy;
                this.init();
            }
            init() {
                for (let i = 1; i <= this.rippleCount; i++) {
                    const decay = Math.pow(0.7, i);
                    const ripple = new Ripple(ctx, this.epicenterX, this.epicenterY, this.rippleSpeed, decay);
                    this.ripples.push(ripple);
                }
                this.ripples[0].sound.play();
            }
            destroyRipple(index) {
                this.ripples.splice(index, 1);
            }
            update() {
                for (let i = 0; i < this.ripples.length; i++) {
                    this.ripples[i].update();
                    if (this.ripples[i].killMe) {
                        this.destroyRipple(i);
                    }
                }
            }
            render() {
                for (let i = 0; i < this.ripples.length; i++) {
                    this.ripples[i].render();
                }
            }
        }

        class Ripple {
            constructor(ctx, cx, cy, r, decay) {
                this.ctx = ctx;
                this.radius = 1;
                this.shadowRadius = 0;
                this.rSpeed = r;
                this.decay = decay;
                this.lineWidth = 12;
                this.epicenterX = cx;
                this.epicenterY = cy;
                this.killMe = false;
                this.opacity = 1;
                this.createSound();
            }
            createSound() {
                this.sound = new Pizzicato.Sound({
                    source: 'wave',
                    options: {
                        volume: Math.min(this.epicenterY / render.height, 1.0),
                        frequency: Math.max(100, Math.min(this.epicenterX * 2, 1000))
                    }
                });
                const delay = new Pizzicato.Effects.DubDelay({
                    feedback: 0.6,
                    time: 0.8,
                    mix: 0.5,
                    cutoff: 600
                });
                this.sound.addEffect(delay);
            }
            update() {
                this.rDelta = this.rSpeed * this.decay;
                this.radius += this.rDelta;
                this.shadowRadius += this.rDelta;
                if (this.radius > 120) {
                    this.sound.stop();
                }
                if (this.lineWidth > 1) {
                    this.lineWidth -= 0.4 * this.decay;
                }
                if (this.radius > 300) {
                    this.opacity -= 0.08;
                }
                if (this.radius > 450) {
                    this.killMe = true;
                }
            }
            render() {
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.lineWidth = this.lineWidth + 3;
                ctx.strokeStyle = `hsla(33, 97%, 49%, ${this.opacity * 0.8})`;
                ctx.arc(this.epicenterX, this.epicenterY, this.shadowRadius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.closePath();
                ctx.beginPath();
                ctx.lineWidth = this.lineWidth;
                ctx.strokeStyle = `hsla(255, 255%, 255%, ${this.opacity})`;
                ctx.arc(this.epicenterX, this.epicenterY, this.radius, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.closePath();
            }
        }

        const waves = [];
        let msgOpacity = 1;
        let started = false;

        const pulseUniforms = {
            uTime: { value: 0.0 },
            uPulsePositions: { value: [new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3)] },
            uPulseTimes: { value: [-1e3, -1e3, -1e3] },
            uPulseColors: { value: [new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1)] },
            uPulseSpeed: { value: 20.0 },
            uBaseNodeSize: { value: 0.7 },
            uActivePalette: { value: 0 },
            uTransitionProgress: { value: 0.0 },
            uBreatheScale: { value: 1.0 }
        };

        const noiseFunctions = `
        vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
        float snoise(vec3 v){
            const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);
            vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);
            vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
            vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);
            vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
            float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;
            vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);
            vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);
            vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;
            vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
            vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
            vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
            p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
            m*=m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
        }
        float fbm(vec3 p,float time){
            float value=0.0;float amplitude=0.5;float frequency=1.0;int octaves=4;
            for(int i=0;i<octaves;i++){
                value+=amplitude*snoise(p*frequency+time*0.3*frequency);
                amplitude*=0.5;frequency*=2.0;
            }
            return value;
        }`;

        const nodeShader = {
            vertexShader: `${noiseFunctions}
            attribute float nodeSize;attribute float nodeType;attribute vec3 nodeColor;attribute vec3 connectionIndices;attribute float distanceFromRoot;
            attribute vec3 targetPosition;
            uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;uniform float uBaseNodeSize;
            uniform float uTransitionProgress;uniform float uBreatheScale;
            varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;

            float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
                if (pulseTime < 0.0) return 0.0;
                float timeSinceClick = uTime - pulseTime;
                if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;
                float pulseRadius = timeSinceClick * uPulseSpeed;
                float distToClick = distance(worldPos, pulsePos);
                float pulseThickness = 3.0;
                float waveProximity = abs(distToClick - pulseRadius);
                return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);
            }

            void main() {
                vNodeType = nodeType;
                vColor = nodeColor;
                vDistanceFromRoot = distanceFromRoot;

                vec3 modifiedPosition = mix(position, targetPosition, uTransitionProgress);
                modifiedPosition *= uBreatheScale;
                vec3 worldPos = (modelMatrix * vec4(modifiedPosition, 1.0)).xyz;
                vPosition = worldPos;

                float totalPulseIntensity = 0.0;
                for (int i = 0; i < 3; i++) {
                    totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
                }
                vPulseIntensity = min(totalPulseIntensity, 1.0);

                float timeScale = 0.6 + 0.4 * sin(uTime * 1.0 + distanceFromRoot * 0.3);
                float baseSize = nodeSize * (0.9 + 0.3 * timeScale);
                float pulseSize = baseSize * (1.0 + vPulseIntensity * 3.0);

                // Use radial direction instead of 'normal' (Points don't have normals)
                if (nodeType > 0.5) {
                    vec3 dir = normalize(modifiedPosition + vec3(0.0001));
                    float noise = fbm(modifiedPosition * 0.15, uTime * 0.2);
                    modifiedPosition += dir * noise * 0.3;
                }

                vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);
                gl_PointSize = pulseSize * uBaseNodeSize * (1000.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }`,

            fragmentShader: `
            uniform float uTime;uniform vec3 uPulseColors[3];uniform int uActivePalette;
            varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;

            void main() {
                vec2 center = 2.0 * gl_PointCoord - 1.0;
                float dist = length(center);
                if (dist > 1.0) discard;

                float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);
                glowStrength = pow(glowStrength, 1.8);

                vec3 baseColor = vColor * (0.9 + 0.3 * sin(uTime * 0.7 + vDistanceFromRoot * 0.4));
                vec3 finalColor = baseColor;

                if (vPulseIntensity > 0.0) {
                    vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.5);
                    finalColor = mix(baseColor, pulseColor, vPulseIntensity);
                    finalColor *= (1.0 + vPulseIntensity * 1.0);
                }

                float alpha = glowStrength * (1.0 - 0.5 * dist);
                float camDistance = length(vPosition - cameraPosition);
                float distanceFade = smoothstep(100.0, 20.0, camDistance);

                if (vNodeType > 0.5) {
                    alpha *= 0.85;
                } else {
                    finalColor *= 1.4;
                }

                gl_FragColor = vec4(finalColor, alpha * distanceFade);
            }`
        };

        const connectionShader = {
            vertexShader: `${noiseFunctions}
            attribute vec3 startPoint;attribute vec3 endPoint;attribute float connectionStrength;attribute float pathIndex;attribute vec3 connectionColor;
            attribute vec3 targetStartPoint;attribute vec3 targetEndPoint;
            uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;
            uniform float uTransitionProgress;uniform float uBreatheScale;
            varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;

            float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {
                if (pulseTime < 0.0) return 0.0;
                float timeSinceClick = uTime - pulseTime;
                if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;
                float pulseRadius = timeSinceClick * uPulseSpeed;
                float distToClick = distance(worldPos, pulsePos);
                float pulseThickness = 3.0;
                float waveProximity = abs(distToClick - pulseRadius);
                return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);
            }

            void main() {
                float t = position.x;
                vPathPosition = t;

                vec3 start = mix(startPoint, targetStartPoint, uTransitionProgress);
                vec3 end = mix(endPoint, targetEndPoint, uTransitionProgress);
                start *= uBreatheScale;
                end *= uBreatheScale;
                vec3 midPoint = mix(start, end, 0.5);
                float pathOffset = sin(t * 3.14159) * 0.2;
                vec3 perpendicular = normalize(cross(normalize(end - start), vec3(0.0, 1.0, 0.0)));
                if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0);
                midPoint += perpendicular * pathOffset;

                vec3 p0 = mix(start, midPoint, t);
                vec3 p1 = mix(midPoint, end, t);
                vec3 finalPos = mix(p0, p1, t);

                float noiseTime = uTime * 0.3;
                float noise = fbm(vec3(pathIndex * 0.15, t * 0.7, noiseTime), noiseTime);
                finalPos += perpendicular * noise * 0.2;

                vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz;

                float totalPulseIntensity = 0.0;
                for (int i = 0; i < 3; i++) {
                    totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
                }
                vPulseIntensity = min(totalPulseIntensity, 1.0);

                vColor = connectionColor;
                vConnectionStrength = connectionStrength;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }`,

            fragmentShader: `
            uniform float uTime;uniform vec3 uPulseColors[3];
            varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;

            void main() {
                vec3 baseColor = vColor * (0.8 + 0.4 * sin(uTime * 0.7 + vPathPosition * 15.0));
                float flowPattern = sin(vPathPosition * 30.0 - uTime * 5.0) * 0.5 + 0.5;
                float flowIntensity = 0.5 * flowPattern * vConnectionStrength;

                vec3 finalColor = baseColor;

                if (vPulseIntensity > 0.0) {
                    vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.5);
                    finalColor = mix(baseColor, pulseColor, vPulseIntensity);
                    flowIntensity += vPulseIntensity * 0.7;
                }

                finalColor *= (0.8 + flowIntensity + vConnectionStrength * 0.6);

                float alpha = 0.9 * vConnectionStrength + 0.3 * flowPattern;
                alpha = mix(alpha, min(1.0, alpha * 2.5), vPulseIntensity);

                gl_FragColor = vec4(finalColor, alpha);
            }`
        };

        class Node {
            constructor(position, level = 0, type = 0) {
                this.position = position;
                this.targetPosition = position.clone();
                this.connections = [];
                this.level = level;
                this.type = type;
                this.size = type === 0 ? THREE.MathUtils.randFloat(0.9, 1.5) : THREE.MathUtils.randFloat(0.6, 1.2);
                this.distanceFromRoot = 0;
                this.spiralIndex = 0;
                this.spiralPosition = 0;
                this.baseAngle = 0;
            }
            addConnection(node, strength = 1.0) {
                if (!this.isConnectedTo(node)) {
                    this.connections.push({ node, strength });
                    node.connections.push({ node: this, strength });
                }
            }
            isConnectedTo(node) {
                return this.connections.some(conn => conn.node === node);
            }
        }

        function generateNeuralNetwork(formationIndex, densityFactor = 1.0) {
            let nodes = [];
            let rootNode;

            function generateWireframeCube() {
                rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
                rootNode.size = 2.0;
                nodes.push(rootNode);
                const size = 25;
                const segments = Math.floor(25 * densityFactor);
                const vertices = [
                    new THREE.Vector3(-size, -size, -size), new THREE.Vector3(size, -size, -size),
                    new THREE.Vector3(size, size, -size), new THREE.Vector3(-size, size, -size),
                    new THREE.Vector3(-size, -size, size), new THREE.Vector3(size, -size, size),
                    new THREE.Vector3(size, size, size), new THREE.Vector3(-size, size, size)
                ];
                vertices.forEach((pos, i) => {
                    const node = new Node(pos, 1, i % 2);
                    node.distanceFromRoot = pos.length();
                    nodes.push(node);
                    rootNode.addConnection(node, 0.95);
                });
                const edges = [
                    [0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4],
                    [0, 4], [1, 5], [2, 6], [3, 7]
                ];
                edges.forEach(([i, j]) => {
                    const node1 = nodes[i + 1], node2 = nodes[j + 1];
                    node1.addConnection(node2, 0.85);
                    for (let s = 1; s < segments; s++) {
                        const t = s / segments;
                        const pos = new THREE.Vector3().lerpVectors(node1.position, node2.position, t);
                        const newNode = new Node(pos, 2, Math.random() < 0.5 ? 1 : 0);
                        newNode.distanceFromRoot = pos.length();
                        nodes.push(newNode);
                        nodes[nodes.length - 2].addConnection(newNode, 0.75);
                        newNode.addConnection(node2, 0.75);
                    }
                });
                for (let i = 1; i <= 8; i++) {
                    for (let j = i + 1; j <= 8; j++) {
                        if (Math.random() < 0.4 * densityFactor) {
                            nodes[i].addConnection(nodes[j], 0.65);
                        }
                    }
                }
                nodes[0].formationIndex = 0;
            }

            function generateSpiral() {
                rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
                rootNode.size = 2.2;
                nodes.push(rootNode);
                const numSpirals = 10;
                const totalHeight = 50;
                const maxRadius = 25;
                const nodesPerSpiral = Math.floor(50 * densityFactor);
                const spiralNodes = [];
                for (let s = 0; s < numSpirals; s++) {
                    const spiralPhase = (s / numSpirals) * Math.PI * 2;
                    const spiralArray = [];
                    for (let i = 0; i < nodesPerSpiral; i++) {
                        const t = i / (nodesPerSpiral - 1);
                        const height = (t - 0.5) * totalHeight;
                        const radius = maxRadius * Math.sin(t * Math.PI);
                        const revolutions = 4;
                        const angle = spiralPhase + t * Math.PI * 2 * revolutions;
                        const pos = new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle));
                        pos.add(new THREE.Vector3(
                            THREE.MathUtils.randFloatSpread(2.5),
                            THREE.MathUtils.randFloatSpread(2.5),
                            THREE.MathUtils.randFloatSpread(2.5)
                        ));
                        const level = Math.floor(t * 8) + 1;
                        const isLeaf = Math.random() < 0.5;
                        const newNode = new Node(pos, level, isLeaf ? 1 : 0);
                        newNode.distanceFromRoot = Math.sqrt(radius * radius + height * height);
                        newNode.spiralIndex = s;
                        newNode.spiralPosition = t;
                        newNode.baseAngle = angle;
                        nodes.push(newNode);
                        spiralArray.push(newNode);
                    }
                    spiralNodes.push(spiralArray);
                }
                for (const spiral of spiralNodes) {
                    rootNode.addConnection(spiral[0], 1.0);
                    for (let i = 0; i < spiral.length - 1; i++) {
                        spiral[i].addConnection(spiral[i + 1], 0.95);
                    }
                }
                for (let s = 0; s < numSpirals; s++) {
                    const currentSpiral = spiralNodes[s];
                    const nextSpiral = spiralNodes[(s + 1) % numSpirals];
                    const connectionPoints = 10;
                    for (let c = 0; c < connectionPoints; c++) {
                        const t = c / (connectionPoints - 1);
                        const idx1 = Math.floor(t * (currentSpiral.length - 1));
                        const idx2 = Math.floor(t * (nextSpiral.length - 1));
                        currentSpiral[idx1].addConnection(nextSpiral[idx2], 0.85);
                    }
                }
                nodes[0].formationIndex = 1;
            }

            function generateDoubleHelix() {
                rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
                rootNode.size = 2.0;
                nodes.push(rootNode);
                const strands = 2;
                const height = 50;
                const radius = 12;
                const nodesPerStrand = Math.floor(40 * densityFactor);
                const strandNodes = [];
                for (let s = 0; s < strands; s++) {
                    const phase = s * Math.PI;
                    const strand = [];
                    for (let i = 0; i < nodesPerStrand; i++) {
                        const t = i / (nodesPerStrand - 1);
                        const y = (t - 0.5) * height;
                        const angle = t * Math.PI * 6 + phase;
                        const pos = new THREE.Vector3(radius * Math.cos(angle), y, radius * Math.sin(angle));
                        pos.add(new THREE.Vector3(
                            THREE.MathUtils.randFloatSpread(2),
                            THREE.MathUtils.randFloatSpread(2),
                            THREE.MathUtils.randFloatSpread(2)
                        ));
                        const level = Math.floor(t * 8) + 1;
                        const isLeaf = Math.random() < 0.5;
                        const newNode = new Node(pos, level, isLeaf ? 1 : 0);
                        newNode.distanceFromRoot = Math.sqrt(radius * radius + y * y);
                        nodes.push(newNode);
                        strand.push(newNode);
                    }
                    strandNodes.push(strand);
                }
                strandNodes.forEach(strand => {
                    rootNode.addConnection(strand[0], 0.95);
                    for (let i = 0; i < strand.length - 1; i++) {
                        strand[i].addConnection(strand[i + 1], 0.9);
                    }
                });
                const crossConnections = Math.floor(20 * densityFactor);
                for (let i = 0; i < crossConnections; i++) {
                    const t = i / (crossConnections - 1);
                    const idx = Math.floor(t * (nodesPerStrand - 1));
                    const node1 = strandNodes[0][idx];
                    const node2 = strandNodes[1][idx];
                    node1.addConnection(node2, 0.8);
                }
                nodes[0].formationIndex = 2;
            }

            function generateMandalas() {
                rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
                rootNode.size = 2.0;
                nodes.push(rootNode);
                const layers = 6;
                const maxRadius = 30;
                const nodesPerLayer = Math.floor(35 * densityFactor);
                for (let layer = 1; layer <= layers; layer++) {
                    const radius = maxRadius * (layer / layers);
                    for (let i = 0; i < nodesPerLayer; i++) {
                        const theta = (i / nodesPerLayer) * Math.PI * 2;
                        const pos = new THREE.Vector3(
                            radius * Math.cos(theta),
                            0,
                            radius * Math.sin(theta)
                        );
                        pos.add(new THREE.Vector3(
                            THREE.MathUtils.randFloatSpread(2),
                            THREE.MathUtils.randFloatSpread(2),
                            THREE.MathUtils.randFloatSpread(2)
                        ));
                        const isLeaf = Math.random() < 0.6;
                        const newNode = new Node(pos, layer, isLeaf ? 1 : 0);
                        newNode.distanceFromRoot = radius;
                        nodes.push(newNode);
                        if (layer === 1) {
                            rootNode.addConnection(newNode, 0.95);
                        } else {
                            const prevLayerNodes = nodes.filter(n => n.level === layer - 1);
                            const closest = prevLayerNodes.reduce((closest, n) => {
                                const dist = n.position.distanceTo(pos);
                                return dist < closest.dist ? { node: n, dist } : closest;
                            }, { node: null, dist: Infinity }).node;
                            if (closest) newNode.addConnection(closest, 0.85);
                        }
                        const nextIdx = (i + 1) % nodesPerLayer;
                        const nextPos = new THREE.Vector3(
                            radius * Math.cos(((nextIdx / nodesPerLayer) * Math.PI * 2)),
                            0,
                            radius * Math.sin(((nextIdx / nodesPerLayer) * Math.PI * 2))
                        );
                        const nextNode = nodes.find(n => n.level === layer && n.position.distanceTo(nextPos) < 4);
                        if (nextNode) newNode.addConnection(nextNode, 0.75);
                    }
                }
                nodes[0].formationIndex = 3;
            }

            function generateBlackHole() {
                rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
                rootNode.size = 2.5;
                nodes.push(rootNode);
                const rings = 8;
                const maxRadius = 35;
                const nodesPerRing = Math.floor(30 * densityFactor);
                for (let r = 1; r <= rings; r++) {
                    const radius = maxRadius * (r / rings) * (0.7 + Math.random() * 0.3);
                    for (let i = 0; i < nodesPerRing; i++) {
                        const theta = (i / nodesPerRing) * Math.PI * 2 + Math.random() * 0.4;
                        const pos = new THREE.Vector3(
                            radius * Math.cos(theta),
                            THREE.MathUtils.randFloatSpread(3),
                            radius * Math.sin(theta)
                        );
                        const isLeaf = Math.random() < 0.7;
                        const newNode = new Node(pos, r, isLeaf ? 1 : 0);
                        newNode.distanceFromRoot = radius;
                        nodes.push(newNode);
                        if (r === 1) {
                            rootNode.addConnection(newNode, 0.95);
                        } else {
                            const prevRingNodes = nodes.filter(n => n.level === r - 1);
                            const closest = prevRingNodes.reduce((closest, n) => {
                                const dist = n.position.distanceTo(pos);
                                return dist < closest.dist ? { node: n, dist } : closest;
                            }, { node: null, dist: Infinity }).node;
                            if (closest) newNode.addConnection(closest, 0.85);
                        }
                        if (Math.random() < 0.5 * densityFactor) {
                            const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
                            if (randomNode !== newNode) newNode.addConnection(randomNode, 0.65);
                        }
                    }
                }
                nodes[0].formationIndex = 4;
            }

            function generateHeart() {
                rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
                rootNode.size = 2.5;
                nodes.push(rootNode);
                const scale = 25;
                const nodesPerSide = Math.floor(40 * densityFactor);
                const sides = 2;
                const sideNodes = [];
                for (let s = 0; s < sides; s++) {
                    const side = [];
                    const xSign = s === 0 ? 1 : -1;
                    for (let i = 0; i < nodesPerSide; i++) {
                        const t = i / (nodesPerSide - 1);
                        const theta = t * Math.PI * 0.5 + Math.PI * 0.75;
                        const x = xSign * 16 * scale * Math.sin(theta) * Math.sin(theta) * Math.sin(theta);
                        const y = scale * (13 * Math.cos(theta) - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta));
                        const z = THREE.MathUtils.randFloatSpread(4);
                        const pos = new THREE.Vector3(x, y, z);
                        pos.add(new THREE.Vector3(
                            THREE.MathUtils.randFloatSpread(2.5),
                            THREE.MathUtils.randFloatSpread(2.5),
                            THREE.MathUtils.randFloatSpread(2.5)
                        ));
                        const isLeaf = Math.random() < 0.6;
                        const newNode = new Node(pos, Math.floor(t * 6) + 1, isLeaf ? 1 : 0);
                        newNode.distanceFromRoot = Math.sqrt(x * x + y * y);
                        newNode.spiralPosition = t; // reuse for animation
                        nodes.push(newNode);
                        side.push(newNode);
                    }
                    sideNodes.push(side);
                }
                sideNodes.forEach(side => {
                    rootNode.addConnection(side[0], 0.95);
                    for (let i = 0; i < side.length - 1; i++) {
                        side[i].addConnection(side[i + 1], 0.9);
                    }
                });
                const crossConnections = Math.floor(20 * densityFactor);
                for (let i = 0; i < crossConnections; i++) {
                    const t = i / (crossConnections - 1);
                    const idx = Math.floor(t * (nodesPerSide - 1));
                    const node1 = sideNodes[0][idx];
                    const node2 = sideNodes[1][idx];
                    node1.addConnection(node2, 0.8);
                }
                for (let i = 0; i < nodesPerSide; i++) {
                    if (Math.random() < 0.6 * densityFactor) {
                        const node1 = sideNodes[0][i];
                        const node2 = sideNodes[1][Math.floor(Math.random() * nodesPerSide)];
                        node1.addConnection(node2, 0.7);
                    }
                }
                nodes[0].formationIndex = 5;
            }

            function generateMovingSpiral() {
                rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);
                rootNode.size = 2.2;
                nodes.push(rootNode);
                const numSpirals = 8;
                const totalHeight = 45;
                const maxRadius = 22;
                const nodesPerSpiral = Math.floor(45 * densityFactor);
                const spiralNodes = [];
                for (let s = 0; s < numSpirals; s++) {
                    const spiralPhase = (s / numSpirals) * Math.PI * 2;
                    const spiralArray = [];
                    for (let i = 0; i < nodesPerSpiral; i++) {
                        const t = i / (nodesPerSpiral - 1);
                        const height = (t - 0.5) * totalHeight;
                        const radius = maxRadius * Math.sin(t * Math.PI);
                        const angle = spiralPhase + t * Math.PI * 2 * 3;
                        const pos = new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle));
                        pos.add(new THREE.Vector3(
                            THREE.MathUtils.randFloatSpread(2),
                            THREE.MathUtils.randFloatSpread(2),
                            THREE.MathUtils.randFloatSpread(2)
                        ));
                        const level = Math.floor(t * 6) + 1;
                        const isLeaf = Math.random() < 0.5 || i > nodesPerSpiral - 3;
                        const newNode = new Node(pos, level, isLeaf ? 1 : 0);
                        newNode.distanceFromRoot = Math.sqrt(radius * radius + height * height);
                        newNode.spiralIndex = s;
                        newNode.spiralPosition = t;
                        newNode.baseAngle = angle;
                        nodes.push(newNode);
                        spiralArray.push(newNode);
                    }
                    spiralNodes.push(spiralArray);
                }
                for (const spiral of spiralNodes) {
                    rootNode.addConnection(spiral[0], 1.0);
                    for (let i = 0; i < spiral.length - 1; i++) {
                        spiral[i].addConnection(spiral[i + 1], 0.95);
                    }
                }
                for (let s = 0; s < numSpirals; s++) {
                    const currentSpiral = spiralNodes[s];
                    const nextSpiral = spiralNodes[(s + 1) % numSpirals];
                    const connectionPoints = 8;
                    for (let c = 0; c < connectionPoints; c++) {
                        const t = c / (connectionPoints - 1);
                        const idx1 = Math.floor(t * (currentSpiral.length - 1));
                        const idx2 = Math.floor(t * (nextSpiral.length - 1));
                        currentSpiral[idx1].addConnection(nextSpiral[idx2], 0.85);
                    }
                }
                nodes[0].formationIndex = 6;
            }

            switch (formationIndex % config.numFormations) {
                case 0: generateWireframeCube(); break;
                case 1: generateSpiral(); break;
                case 2: generateDoubleHelix(); break;
                case 3: generateMandalas(); break;
                case 4: generateBlackHole(); break;
                case 5: generateHeart(); break;
                case 6: generateMovingSpiral(); break;
            }
            if (densityFactor < 1.0) {
                const originalNodeCount = nodes.length;
                nodes = nodes.filter((node, index) => {
                    if (node === rootNode) return true;
                    const hash = (index * 31 + Math.floor(densityFactor * 100)) % 100;
                    return hash < (densityFactor * 100);
                });
                nodes.forEach(node => {
                    node.connections = node.connections.filter(conn => nodes.includes(conn.node));
                });
                console.log(`Density Filter: ${originalNodeCount} -> ${nodes.length} nodes`);
            }
            return { nodes, rootNode };
        }

        let neuralNetwork = null, nodesMesh = null, connectionsMesh = null;

        function createNetworkVisualization(formationIndex, densityFactor = 1.0, transition = true) {
            config.currentFormation = formationIndex;
            document.getElementById('formation-label').textContent = config.formationNames[formationIndex];

            if (!transition) {
                if (nodesMesh) {
                    scene.remove(nodesMesh);
                    nodesMesh.geometry.dispose();
                    nodesMesh.material.dispose();
                    nodesMesh = null;
                }
                if (connectionsMesh) {
                    scene.remove(connectionsMesh);
                    connectionsMesh.geometry.dispose();
                    connectionsMesh.material.dispose();
                    connectionsMesh = null;
                }
            }

            const newNetwork = generateNeuralNetwork(formationIndex, densityFactor);
            if (!newNetwork || newNetwork.nodes.length === 0) {
                console.error("Network generation failed or resulted in zero nodes.");
                return;
            }

            if (transition && neuralNetwork) {
                config.targetFormation = newNetwork;
                config.isTransitioning = true;
                config.transitionProgress = 0;

                // Map new nodes onto old positions to transition
                newNetwork.nodes.forEach((newNode, i) => {
                    const oldNode = neuralNetwork.nodes[i] || neuralNetwork.nodes[0];
                    newNode.position.copy(oldNode.position);
                    newNode.connections = oldNode.connections.map(conn => ({
                        node: newNetwork.nodes[neuralNetwork.nodes.indexOf(conn.node)] || newNode,
                        strength: conn.strength
                    }));
                });
                neuralNetwork.nodes.forEach((node, i) => {
                    node.targetPosition = newNetwork.nodes[i] ? newNetwork.nodes[i].position.clone() : node.position.clone();
                });
                return;
            }

            neuralNetwork = newNetwork;

            // Nodes
            const nodesGeometry = new THREE.BufferGeometry();
            const nodePositions = [], targetPositions = [], nodeTypes = [], nodeSizes = [], nodeColors = [], connectionIndices = [], distancesFromRoot = [];
            neuralNetwork.nodes.forEach((node) => {
                nodePositions.push(node.position.x, node.position.y, node.position.z);
                targetPositions.push(node.position.x, node.position.y, node.position.z);
                nodeTypes.push(node.type);
                nodeSizes.push(node.size);
                distancesFromRoot.push(node.distanceFromRoot);
                const indices = node.connections.slice(0, 3).map(conn => neuralNetwork.nodes.indexOf(conn.node));
                while (indices.length < 3) indices.push(-1);
                connectionIndices.push(...indices);
                const palette = colorPalettes[config.activePaletteIndex];
                const colorIndex = Math.min(node.level, palette.length - 1);
                const baseColor = palette[colorIndex % palette.length].clone();
                baseColor.offsetHSL(
                    THREE.MathUtils.randFloatSpread(0.06),
                    THREE.MathUtils.randFloatSpread(0.12),
                    THREE.MathUtils.randFloatSpread(0.12)
                );
                nodeColors.push(baseColor.r, baseColor.g, baseColor.b);
            });
            nodesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions, 3));
            nodesGeometry.setAttribute('targetPosition', new THREE.Float32BufferAttribute(targetPositions, 3));
            nodesGeometry.setAttribute('nodeType', new THREE.Float32BufferAttribute(nodeTypes, 1));
            nodesGeometry.setAttribute('nodeSize', new THREE.Float32BufferAttribute(nodeSizes, 1));
            nodesGeometry.setAttribute('nodeColor', new THREE.Float32BufferAttribute(nodeColors, 3));
            nodesGeometry.setAttribute('connectionIndices', new THREE.Float32BufferAttribute(connectionIndices, 3));
            nodesGeometry.setAttribute('distanceFromRoot', new THREE.Float32BufferAttribute(distancesFromRoot, 1));
            const nodesMaterial = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(pulseUniforms),
                vertexShader: nodeShader.vertexShader,
                fragmentShader: nodeShader.fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            nodesMesh = new THREE.Points(nodesGeometry, nodesMaterial);
            scene.add(nodesMesh);

            // Connections
            const connectionsGeometry = new THREE.BufferGeometry();
            const connectionColors = [], connectionStrengths = [], connectionPositions = [], startPoints = [], endPoints = [], targetStartPoints = [], targetEndPoints = [], pathIndices = [];
            const processedConnections = new Set();
            let pathIndex = 0;
            const numSegments = 20;

            neuralNetwork.nodes.forEach((node, nodeIndex) => {
                node.connections.forEach(connection => {
                    const connectedNode = connection.node;
                    const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
                    if (connectedIndex === -1) return;
                    const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
                    if (!processedConnections.has(key)) {
                        processedConnections.add(key);
                        const startPoint = node.position;
                        const endPoint = connectedNode.position;
                        for (let i = 0; i < numSegments; i++) {
                            const t = i / (numSegments - 1);
                            connectionPositions.push(t, 0, 0);
                            startPoints.push(startPoint.x, startPoint.y, startPoint.z);
                            endPoints.push(endPoint.x, endPoint.y, endPoint.z);
                            targetStartPoints.push(startPoint.x, startPoint.y, startPoint.z);
                            targetEndPoints.push(endPoint.x, endPoint.y, endPoint.z);
                            pathIndices.push(pathIndex);
                            connectionStrengths.push(connection.strength);
                            const palette = colorPalettes[config.activePaletteIndex];
                            const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);
                            const baseColor = palette[avgLevel % palette.length].clone();
                            baseColor.offsetHSL(
                                THREE.MathUtils.randFloatSpread(0.06),
                                THREE.MathUtils.randFloatSpread(0.12),
                                THREE.MathUtils.randFloatSpread(0.12)
                            );
                            connectionColors.push(baseColor.r, baseColor.g, baseColor.b);
                        }
                        pathIndex++;
                    }
                });
            });
            connectionsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(connectionPositions, 3));
            connectionsGeometry.setAttribute('startPoint', new THREE.Float32BufferAttribute(startPoints, 3));
            connectionsGeometry.setAttribute('endPoint', new THREE.Float32BufferAttribute(endPoints, 3));
            connectionsGeometry.setAttribute('targetStartPoint', new THREE.Float32BufferAttribute(targetStartPoints, 3));
            connectionsGeometry.setAttribute('targetEndPoint', new THREE.Float32BufferAttribute(targetEndPoints, 3));
            connectionsGeometry.setAttribute('connectionStrength', new THREE.Float32BufferAttribute(connectionStrengths, 1));
            connectionsGeometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));
            connectionsGeometry.setAttribute('pathIndex', new THREE.Float32BufferAttribute(pathIndices, 1));
            const connectionsMaterial = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(pulseUniforms),
                vertexShader: connectionShader.vertexShader,
                fragmentShader: connectionShader.fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            connectionsMesh = new THREE.LineSegments(connectionsGeometry, connectionsMaterial);
            scene.add(connectionsMesh);

            const palette = colorPalettes[config.activePaletteIndex];
            connectionsMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);
            connectionsMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);
            connectionsMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);
            nodesMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);
            nodesMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);
            nodesMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);
            nodesMaterial.uniforms.uActivePalette.value = config.activePaletteIndex;
        }

        function updateTheme(paletteIndex) {
            config.activePaletteIndex = paletteIndex;
            if (!nodesMesh || !connectionsMesh || !starfield.points) return;

            const palette = colorPalettes[paletteIndex];

            // Update node colors
            const nodeColorsAttr = nodesMesh.geometry.attributes.nodeColor;
            for (let i = 0; i < nodeColorsAttr.count; i++) {
                const node = neuralNetwork.nodes[i];
                if (!node) continue;
                const colorIndex = Math.min(node.level, palette.length - 1);
                const baseColor = palette[colorIndex % palette.length].clone();
                baseColor.offsetHSL(
                    THREE.MathUtils.randFloatSpread(0.06),
                    THREE.MathUtils.randFloatSpread(0.12),
                    THREE.MathUtils.randFloatSpread(0.12)
                );
                nodeColorsAttr.setXYZ(i, baseColor.r, baseColor.g, baseColor.b);
            }
            nodeColorsAttr.needsUpdate = true;

            // Update connection colors
            const connectionColors = [];
            const processedConnections = new Set();
            const numSegments = 20;
            neuralNetwork.nodes.forEach((node, nodeIndex) => {
                node.connections.forEach(connection => {
                    const connectedNode = connection.node;
                    const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
                    if (connectedIndex === -1) return;
                    const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
                    if (!processedConnections.has(key)) {
                        processedConnections.add(key);
                        for (let i = 0; i < numSegments; i++) {
                            const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);
                            const baseColor = palette[avgLevel % palette.length].clone();
                            baseColor.offsetHSL(
                                THREE.MathUtils.randFloatSpread(0.06),
                                THREE.MathUtils.randFloatSpread(0.12),
                                THREE.MathUtils.randFloatSpread(0.12)
                            );
                            connectionColors.push(baseColor.r, baseColor.g, baseColor.b);
                        }
                    }
                });
            });
            connectionsMesh.geometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));
            connectionsMesh.geometry.attributes.connectionColor.needsUpdate = true;

            // Update pulse colors
            nodesMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));
            connectionsMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));
            nodesMesh.material.uniforms.uActivePalette.value = paletteIndex;

            // Update star colors
            const starColors = starfield.points.geometry.attributes.color;
            for (let i = 0; i < starColors.count; i++) {
                const color = palette[Math.floor(Math.random() * palette.length)].clone();
                color.offsetHSL(
                    THREE.MathUtils.randFloatSpread(0.15),
                    THREE.MathUtils.randFloatSpread(0.3),
                    THREE.MathUtils.randFloatSpread(0.3)
                );
                starColors.setXYZ(i, color.r, color.g, color.b);
            }
            starColors.needsUpdate = true;

            // Shooting stars color
            starfield.shootingStars.forEach(star => {
                star.line.material.color.copy(palette[Math.floor(Math.random() * palette.length)]);
            });
        }

        // Interaction helpers (declare once, at top level)
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const interactionPoint = new THREE.Vector3();
        let lastPulseIndex = 0;

        function triggerPulse(clientX, clientY) {
            started = true;
            pointer.x = (clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            interactionPlane.normal.copy(camera.position).normalize();
            interactionPlane.constant = -interactionPlane.normal.dot(camera.position) + camera.position.length() * 0.5;
            if (raycaster.ray.intersectPlane(interactionPlane, interactionPoint)) {
                const time = clock.getElapsedTime();
                if (nodesMesh && connectionsMesh) {
                    lastPulseIndex = (lastPulseIndex + 1) % 3;
                    nodesMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint);
                    nodesMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;
                    connectionsMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint);
                    connectionsMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;
                    const palette = colorPalettes[config.activePaletteIndex];
                    const randomColor = palette[Math.floor(Math.random() * palette.length)];
                    nodesMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);
                    connectionsMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);
                }
                waves.push(new Wave(clientX * render.dpi, clientY * render.dpi));
            }
        }

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('.ui-panel')) return;
            triggerPulse(e.clientX, e.clientY);
        });
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.target.closest('.ui-panel')) return;
            e.preventDefault();
            if (e.touches.length === 1) {
                triggerPulse(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        let touchStartX = 0;
        renderer.domElement.addEventListener('touchstart', (e) => {
            if (e.target.closest('.ui-panel')) return;
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
            }
        }, { passive: false });

        renderer.domElement.addEventListener('touchend', (e) => {
            if (e.target.closest('.ui-panel')) return;
            if (e.changedTouches.length === 1 && !config.isTransitioning) {
                const touchEndX = e.changedTouches[0].clientX;
                const deltaX = touchEndX - touchStartX;
                if (Math.abs(deltaX) > 100) {
                    const newFormation = deltaX > 0 ?
                        (config.currentFormation + 1) % config.numFormations :
                        (config.currentFormation - 1 + config.numFormations) % config.numFormations;
                    createNetworkVisualization(newFormation, config.densityFactor, true);
                    controls.autoRotate = false;
                    setTimeout(() => { controls.autoRotate = true; }, 4000);
                }
            }
        }, { passive: false });

        document.addEventListener('keydown', (e) => {
            if (e.target.closest('.ui-panel')) return;
            if (!config.isTransitioning) {
                if (e.key === '1') {
                    const newFormation = (config.currentFormation - 1 + config.numFormations) % config.numFormations;
                    createNetworkVisualization(newFormation, config.densityFactor, true);
                    controls.autoRotate = false;
                    setTimeout(() => { controls.autoRotate = true; }, 4000);
                } else if (e.key === '2') {
                    const newFormation = (config.currentFormation + 1) % config.numFormations;
                    createNetworkVisualization(newFormation, config.densityFactor, true);
                    controls.autoRotate = false;
                    setTimeout(() => { controls.autoRotate = true; }, 4000);
                }
            }
        });

        window.addEventListener('deviceorientation', (e) => {
            if (e.beta !== null && Math.abs(e.beta) > 60) {
                controls.reset();
                controls.autoRotate = false;
                setTimeout(() => { controls.autoRotate = true; }, 2000);
            }
        });

        const themeButtons = document.querySelectorAll('.theme-button');
        themeButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const idx = parseInt(btn.dataset.theme, 10);
                updateTheme(idx);
                themeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        const densitySlider = document.getElementById('density-slider');
        const densityValue = document.getElementById('density-value');
        let densityTimeout;
        densitySlider.addEventListener('input', (e) => {
            e.stopPropagation();
            const val = parseInt(densitySlider.value, 10);
            config.densityFactor = val / 100;
            densityValue.textContent = `${val}%`;
            clearTimeout(densityTimeout);
            densityTimeout = setTimeout(() => {
                createNetworkVisualization(config.currentFormation, config.densityFactor, false);
            }, 300);
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            if (started) {
                msgOpacity = Math.max(0, msgOpacity - 0.05);
            }

            if (config.isTransitioning && neuralNetwork && config.targetFormation) {
                config.transitionProgress += 1 / (config.transitionDuration * 60);
                const easedProgress = easingUtils.easeInOutCubic(config.transitionProgress);
                if (config.transitionProgress >= 1) {
                    config.transitionProgress = 0;
                    config.isTransitioning = false;
                    config.currentFormation = config.targetFormation.nodes[0].formationIndex || (config.currentFormation + 1) % config.numFormations;
                    createNetworkVisualization(config.currentFormation, config.densityFactor, false);
                } else {
                    nodesMesh.material.uniforms.uTransitionProgress.value = easedProgress;
                    connectionsMesh.material.uniforms.uTransitionProgress.value = easedProgress;

                    const nodePositions = nodesMesh.geometry.attributes.position.array;
                    neuralNetwork.nodes.forEach((node, i) => {
                        const target = config.targetFormation.nodes[i] || config.targetFormation.nodes[0];
                        nodePositions[i * 3] = THREE.MathUtils.lerp(node.position.x, target.position.x, easedProgress);
                        nodePositions[i * 3 + 1] = THREE.MathUtils.lerp(node.position.y, target.position.y, easedProgress);
                        nodePositions[i * 3 + 2] = THREE.MathUtils.lerp(node.position.z, target.position.z, easedProgress);
                    });
                    nodesMesh.geometry.attributes.position.needsUpdate = true;

                    const startArr = connectionsMesh.geometry.attributes.startPoint.array;
                    const endArr = connectionsMesh.geometry.attributes.endPoint.array;
                    const targetStartArr = connectionsMesh.geometry.attributes.targetStartPoint.array;
                    const targetEndArr = connectionsMesh.geometry.attributes.targetEndPoint.array;

                    let connIndex = 0;
                    const processedConnections = new Set();
                    const numSegments = 20;

                    neuralNetwork.nodes.forEach((node, nodeIndex) => {
                        node.connections.forEach(connection => {
                            const connectedNode = connection.node;
                            const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
                            if (connectedIndex === -1) return;
                            const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
                            if (!processedConnections.has(key)) {
                                processedConnections.add(key);
                                const targetNode1 = config.targetFormation.nodes[nodeIndex] || config.targetFormation.nodes[0];
                                const targetNode2 = config.targetFormation.nodes[connectedIndex] || config.targetFormation.nodes[0];
                                for (let i = 0; i < numSegments; i++) {
                                    startArr[connIndex * 3] = THREE.MathUtils.lerp(startArr[connIndex * 3], targetNode1.position.x, easedProgress);
                                    startArr[connIndex * 3 + 1] = THREE.MathUtils.lerp(startArr[connIndex * 3 + 1], targetNode1.position.y, easedProgress);
                                    startArr[connIndex * 3 + 2] = THREE.MathUtils.lerp(startArr[connIndex * 3 + 2], targetNode1.position.z, easedProgress);

                                    endArr[connIndex * 3] = THREE.MathUtils.lerp(endArr[connIndex * 3], targetNode2.position.x, easedProgress);
                                    endArr[connIndex * 3 + 1] = THREE.MathUtils.lerp(endArr[connIndex * 3 + 1], targetNode2.position.y, easedProgress);
                                    endArr[connIndex * 3 + 2] = THREE.MathUtils.lerp(endArr[connIndex * 3 + 2], targetNode2.position.z, easedProgress);

                                    targetStartArr[connIndex * 3] = targetNode1.position.x;
                                    targetStartArr[connIndex * 3 + 1] = targetNode1.position.y;
                                    targetStartArr[connIndex * 3 + 2] = targetNode1.position.z;

                                    targetEndArr[connIndex * 3] = targetNode2.position.x;
                                    targetEndArr[connIndex * 3 + 1] = targetNode2.position.y;
                                    targetEndArr[connIndex * 3 + 2] = targetNode2.position.z;

                                    connIndex++;
                                }
                            }
                        });
                    });
                    connectionsMesh.geometry.attributes.startPoint.needsUpdate = true;
                    connectionsMesh.geometry.attributes.endPoint.needsUpdate = true;
                    connectionsMesh.geometry.attributes.targetStartPoint.needsUpdate = true;
                    connectionsMesh.geometry.attributes.targetEndPoint.needsUpdate = true;
                }
            }

            // Breathe
            config.breatheScale = 1.0 + 0.05 * Math.sin(t * 0.8);
            if (nodesMesh && connectionsMesh) {
                nodesMesh.material.uniforms.uBreatheScale.value = config.breatheScale;
                connectionsMesh.material.uniforms.uBreatheScale.value = config.breatheScale;
            }

            // Moving formations
            if (neuralNetwork && neuralNetwork.nodes[0].formationIndex === 6) {
                const nodePositions = nodesMesh.geometry.attributes.position.array;
                neuralNetwork.nodes.forEach((node, i) => {
                    if (node.spiralIndex !== undefined) {
                        const angle = node.baseAngle + t * 0.2;
                        const radius = 22 * Math.sin(node.spiralPosition * Math.PI);
                        const height = (node.spiralPosition - 0.5) * 45;
                        nodePositions[i * 3] = radius * Math.cos(angle);
                        nodePositions[i * 3 + 1] = height;
                        nodePositions[i * 3 + 2] = radius * Math.sin(angle);
                    }
                });
                nodesMesh.geometry.attributes.position.needsUpdate = true;

                // Update connection endpoints to match new positions
                let connIndex = 0;
                const processedConnections = new Set();
                const numSegments = 20;
                neuralNetwork.nodes.forEach((node, nodeIndex) => {
                    node.connections.forEach(connection => {
                        const connectedNode = connection.node;
                        const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
                        if (connectedIndex === -1) return;
                        const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
                        if (!processedConnections.has(key)) {
                            processedConnections.add(key);
                            const startNode = neuralNetwork.nodes[nodeIndex];
                            const endNode = neuralNetwork.nodes[connectedIndex];
                            for (let i = 0; i < numSegments; i++) {
                                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3] = startNode.position.x;
                                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 1] = startNode.position.y;
                                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 2] = startNode.position.z;
                                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3] = endNode.position.x;
                                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 1] = endNode.position.y;
                                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 2] = endNode.position.z;
                                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3] = startNode.position.x;
                                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3 + 1] = startNode.position.y;
                                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3 + 2] = startNode.position.z;
                                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3] = endNode.position.x;
                                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3 + 1] = endNode.position.y;
                                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3 + 2] = endNode.position.z;
                                connIndex++;
                            }
                        }
                    });
                });
                connectionsMesh.geometry.attributes.startPoint.needsUpdate = true;
                connectionsMesh.geometry.attributes.endPoint.needsUpdate = true;
                connectionsMesh.geometry.attributes.targetStartPoint.needsUpdate = true;
                connectionsMesh.geometry.attributes.targetEndPoint.needsUpdate = true;
            }

            if (neuralNetwork && neuralNetwork.nodes[0].formationIndex === 5) {
                const nodePositions = nodesMesh.geometry.attributes.position.array;
                neuralNetwork.nodes.forEach((node, i) => {
                    if (node.level > 0) {
                        const tt = node.spiralPosition || 0;
                        const xSign = node.position.x > 0 ? 1 : -1;
                        const theta = tt * Math.PI * 0.5 + Math.PI * 0.75;
                        const scale = 25 + 2 * Math.sin(tt * 1.5);
                        const x = xSign * 16 * scale * Math.pow(Math.sin(theta), 3.0);
                        const y = scale * (13 * Math.cos(theta) - 5 * Math.cos(2 * theta) - 2 * Math.cos(3 * theta) - Math.cos(4 * theta));
                        const z = THREE.MathUtils.randFloatSpread(4);
                        nodePositions[i * 3] = x;
                        nodePositions[i * 3 + 1] = y;
                        nodePositions[i * 3 + 2] = z;
                    }
                });
                nodesMesh.geometry.attributes.position.needsUpdate = true;

                let connIndex = 0;
                const processedConnections = new Set();
                const numSegments = 20;
                neuralNetwork.nodes.forEach((node, nodeIndex) => {
                    node.connections.forEach(connection => {
                        const connectedNode = connection.node;
                        const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
                        if (connectedIndex === -1) return;
                        const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
                        if (!processedConnections.has(key)) {
                            processedConnections.add(key);
                            const startNode = neuralNetwork.nodes[nodeIndex];
                            const endNode = neuralNetwork.nodes[connectedIndex];
                            for (let i = 0; i < numSegments; i++) {
                                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3] = startNode.position.x;
                                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 1] = startNode.position.y;
                                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 2] = startNode.position.z;
                                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3] = endNode.position.x;
                                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 1] = endNode.position.y;
                                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 2] = endNode.position.z;
                                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3] = startNode.position.x;
                                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3 + 1] = startNode.position.y;
                                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3 + 2] = startNode.position.z;
                                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3] = endNode.position.x;
                                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3 + 1] = endNode.position.y;
                                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3 + 2] = endNode.position.z;
                                connIndex++;
                            }
                        }
                    });
                });
                connectionsMesh.geometry.attributes.startPoint.needsUpdate = true;
                connectionsMesh.geometry.attributes.endPoint.needsUpdate = true;
                connectionsMesh.geometry.attributes.targetStartPoint.needsUpdate = true;
                connectionsMesh.geometry.attributes.targetEndPoint.needsUpdate = true;
            }

            // Starfield motion
            const posArr = starfield.points.geometry.attributes.position.array;
            const velArr = starfield.points.geometry.attributes.velocity.array;
            for (let i = 0; i < posArr.length; i++) {
                posArr[i] += velArr[i] * 0.1;
                if (Math.abs(posArr[i]) > 200) {
                    posArr[i] *= -0.5;
                }
            }
            starfield.points.geometry.attributes.position.needsUpdate = true;

            // Shooting stars
            starfield.shootingStars = starfield.shootingStars.filter(star => star.life > 0);
            if (Math.random() < 0.02) {
                const newStar = createShootingStar();
                scene.add(newStar.line);
                starfield.shootingStars.push(newStar);
            }
            starfield.shootingStars.forEach(star => {
                const positions = star.line.geometry.attributes.position.array;
                star.life -= 0.016;
                star.line.material.opacity = star.life / 2.5;
                for (let i = 0; i < 2; i++) {
                    positions[i * 3] += star.direction.x * 5;
                    positions[i * 3 + 1] += star.direction.y * 5;
                    positions[i * 3 + 2] += star.direction.z * 5;
                }
                star.line.geometry.attributes.position.needsUpdate = true;
                if (star.life <= 0) {
                    scene.remove(star.line);
                    star.line.geometry.dispose();
                    star.line.material.dispose();
                }
            });

            // Uniform time
            if (nodesMesh && connectionsMesh) {
                nodesMesh.material.uniforms.uTime.value = t;
                connectionsMesh.material.uniforms.uTime.value = t;
            }

            controls.update();

            // Ripples overlay
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            waves.forEach(wave => {
                wave.update();
                wave.render();
            });

            composer.render();
        }

        window.addEventListener('resize', () => {
            render.width = window.innerWidth;
            render.hWidth = render.width * 0.5;
            render.height = window.innerHeight;
            render.hHeight = render.height * 0.5;
            render.dpi = window.devicePixelRatio;
            overlayCanvas.width = render.width * render.dpi;
            overlayCanvas.height = render.height * render.dpi;

            camera.aspect = render.width / render.height;
            camera.updateProjectionMatrix();
            renderer.setSize(render.width, render.height);
            composer.setSize(render.width, render.height);
        });

        createNetworkVisualization(0, 1.0, false);
        animate();
    </script>
</body>
</html>