<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neural Network Visualization</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* Cursor as a magical wand emoji */
    html, body {
      height: 100%;
    }
    html {
      /* Magical wand cursor, uses a data-URL SVG with the emoji. Fallback to auto. */
      cursor: url('data:image/svg+xml;utf8,\
<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32">\
  <text x="0" y="26" font-family="Segoe UI Emoji" font-size="22">ü™Ñ</text>\
</svg>') 16 16, auto;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; }

    /* Canvases: WebGL for visuals, overlay 2D for pulsing ripples (sourced from 2D canvas) */
    canvas#webgl-canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
    canvas#ripples-canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 2; pointer-events: none; }

    /* UI Panel: Visual Theme with breathing animation, 90% opaque, 10% transparent */
    .ui-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10;
      padding: 15px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.9); /* 90% opaque (10% transparent) */
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 120, 50, 0.3);
      color: #eee;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      animation: breathe 6s ease-in-out infinite;
    }
    @keyframes breathe {
      0%,100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    #theme-selector-title { font-weight: 600; font-size: 15px; margin-bottom: 10px; }
    #formation-label { font-size: 13px; margin-top: 10px; color: rgba(255, 120, 50, 0.9); }

    .theme-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; justify-items: center; }
    .theme-button {
      width: 36px; height: 36px; border-radius: 8px;
      border: 2px solid rgba(255,255,255,0.3);
      cursor: pointer; transition: transform 0.2s, border-color 0.2s;
      outline: none; overflow: hidden;
    }
    .theme-button:hover, .theme-button:focus { transform: scale(1.05); border-color: rgba(255, 255, 255, 0.7); }
    .theme-button.active {
      transform: scale(1.05);
      border-color: rgba(255, 255, 255, 0.9);
      box-shadow: 0 0 10px rgba(255, 200, 150, 0.6);
    }
    #theme-1 { background: linear-gradient(45deg, #4F46E5, #7C3AED, #C026D3, #DB2777); }
    #theme-2 { background: linear-gradient(45deg, #F59E0B, #F97316, #DC2626, #7F1D1D); }
    #theme-3 { background: linear-gradient(45deg, #EC4899, #8B5CF6, #6366F1, #3B82F6); }
    #theme-4 { background: linear-gradient(45deg, #10B981, #A3E635, #FACC15, #FB923C); }

    /* Subtle glow + breathing for PITCH & VOLUME and their container */
    .legend {
      position: absolute;
      left: 25px;
      bottom: 25px;
      z-index: 9;
      color: white; font-family: 'Orbitron', sans-serif;
      display: flex; gap: 14px; align-items: center;
      pointer-events: none;
    }
    .legend p { user-select: none; font-size: 12px; text-transform: uppercase; letter-spacing: 5px; animation: legendGlow 3s ease-in-out infinite; }
    .legend p.vert { writing-mode: vertical-lr; transform: rotate(180deg); font-size: 12px; }
    @keyframes legendGlow {
      0% { text-shadow: 0 0 6px rgba(255,255,255,.6); filter: saturate(1.0); }
      50% { text-shadow: 0 0 18px rgba(255,255,255,1.0); filter: saturate(1.2); }
      100% { text-shadow: 0 0 6px rgba(255,255,255,.6); filter: saturate(1.0); }
    }

    /* Watermark */
    .watermark {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 40px; opacity: 0.95; z-index: 9;
      padding: 6px 12px; background: rgba(0,0,0,0.25);
      border-radius: 8px;
      animation: floatWatermark 6s ease-in-out infinite;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }
    @keyframes floatWatermark {
      0% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-6px); }
      100% { transform: translateX(-50%) translateY(0); }
    }

    /* Arrows under the Visual Theme modal (navigation) */
    .theme-arrows {
      display: flex; gap: 12px; margin-top: 8px;
    }
    .arrow-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.25);
      color: #fff; width: 32px; height: 26px; border-radius: 6px;
      font-size: 16px; line-height: 22px; cursor: pointer;
    }
    .arrow-btn:hover { background: rgba(255,255,255,0.18); }

    /* Density slider styling kept minimal but usable */
    #density-controls { margin-top: 12px; display: flex; flex-direction: column; gap: 8px; width: 100%; }

    @media (max-width: 640px) {
      .theme-grid { grid-template-columns: repeat(4, 1fr); }
      .legend { left: 12px; bottom: 12px; }
    }
  </style>
</head>
<body>
  <div id="theme-selector" class="ui-panel" aria-label="Visual Theme">
    <div id="theme-selector-title">Visual Theme</div>
    <div class="theme-grid">
      <button class="theme-button active" id="theme-1" data-theme="0" aria-label="Theme 1"></button>
      <button class="theme-button" id="theme-2" data-theme="1" aria-label="Theme 2"></button>
      <button class="theme-button" id="theme-3" data-theme="2" aria-label="Theme 3"></button>
      <button class="theme-button" id="theme-4" data-theme="3" aria-label="Theme 4"></button>
    </div>
    <div id="density-controls">
      <div class="density-label" style="width:100%; display:flex; justify-content: space-between;">
        <span>Density</span><span id="density-value">100%</span>
      </div>
      <input type="range" min="20" max="100" value="100" class="density-slider" id="density-slider" aria-label="Network Density" />
    </div>

    <!-- Arrows for navigation (Left = previous, Right = next) -->
    <div class="theme-arrows" aria-label="Navigate Formations">
      <button id="prev-formation" class="arrow-btn" title="Previous formation">‚Üê</button>
      <button id="next-formation" class="arrow-btn" title="Next formation">‚Üí</button>
    </div>

    <div id="formation-label">Cube</div>
  </div>

  <div class="legend" aria-label="Pitch and Volume">
    <p id="legend-pitch" style="text-shadow:0 0 6px rgba(255,255,255,.6); animation: legendGlow 3s ease-in-out infinite;">Pitch</p>
    <p class="vert" id="legend-volume" style="text-shadow:0 0 6px rgba(255,255,255,.6); animation: legendGlow 3s ease-in-out infinite;">Volume</p>
  </div>

  <canvas id="webgl-canvas"></canvas>
  <canvas id="ripples-canvas"></canvas>

  <img class="watermark" id="proto-watermark" alt="Proto watermark" src="https://paradoxuni.b-cdn.net/!File%20Organization/!PROTOTYPE/ProtoLogo.png" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pizzicato/0.6.4/Pizzicato.min.js"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/",
      "easing-utils": "https://esm.sh/easing-utils"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    // Local easing function (no external dependency)
    const easeInOutCubic = (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);

    // Config
    const config = {
      activePaletteIndex: 0,
      currentFormation: 0,
      numFormations: 6, // Cube, Spiral, Double Helix, Mandalas, Black Hole, Moving Spiral
      densityFactor: 1,
      isTransitioning: false,
      transitionProgress: 0,
      transitionDuration: 3.5,
      targetFormation: null,
      formationNames: ['Cube', 'Spiral', 'Double Helix', 'Mandalas', 'Black Hole', 'Moving Spiral'],
      breatheScale: 1
    };

    // Color palettes
    const colorPalettes = [
      [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)],
      [new THREE.Color(0xF59E0B), new THREE.Color(0xF97316), new THREE.Color(0xDC2626), new THREE.Color(0x7F1D1D), new THREE.Color(0xFBBF24)],
      [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)],
      [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)]
    ];

    // Scene setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.001);
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
    camera.position.set(0, 5, 25);

    // Canvases
    const webglCanvas = document.getElementById('webgl-canvas');
    const ripplesCanvas = document.getElementById('ripples-canvas');
    const ctx = ripplesCanvas.getContext('2d');

    // Renderers
    const renderer = new THREE.WebGLRenderer({ canvas: webglCanvas, antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // Overlay render size
    ripplesCanvas.width = window.innerWidth * Math.min(window.devicePixelRatio, 2);
    ripplesCanvas.height = window.innerHeight * Math.min(window.devicePixelRatio, 2);

    // Create starfield etc. (unchanged logic retained; implemented within corrected structure)
    function createStarfield() {
      const count = 15000, pos = [], colors = [], velocities = [];
      const palette = colorPalettes[config.activePaletteIndex];
      for (let i = 0; i < count; i++) {
        const r = THREE.MathUtils.randFloat(50, 200);
        const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
        const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);
        pos.push(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta),
          r * Math.cos(phi)
        );
        const color = palette[Math.floor(Math.random() * palette.length)].clone();
        color.offsetHSL(
          THREE.MathUtils.randFloatSpread(0.15),
          THREE.MathUtils.randFloatSpread(0.3),
          THREE.MathUtils.randFloatSpread(0.3)
        );
        colors.push(color.r, color.g, color.b);
        velocities.push(
          THREE.MathUtils.randFloatSpread(0.1),
          THREE.MathUtils.randFloatSpread(0.1),
          THREE.MathUtils.randFloatSpread(0.1)
        );
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
      const mat = new THREE.PointsMaterial({
        size: 0.25, sizeAttenuation: true, depthWrite: false,
        opacity: 0.85, transparent: true, vertexColors: true
      });
      return { points: new THREE.Points(geo, mat), shootingStars: [] };
    }

    const starfield = createStarfield();
    scene.add(starfield.points);

    function createShootingStar() {
      const pos = new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(200),
        THREE.MathUtils.randFloatSpread(200),
        THREE.MathUtils.randFloatSpread(200)
      );
      const dir = new THREE.Vector3(
        THREE.MathUtils.randFloatSpread(1),
        THREE.MathUtils.randFloatSpread(1),
        THREE.MathUtils.randFloatSpread(1)
      ).normalize();
      const geo = new THREE.BufferGeometry();
      const positions = [pos.x, pos.y, pos.z, pos.x + dir.x * 4, pos.y + dir.y * 4, pos.z + dir.z * 4];
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const palette = colorPalettes[config.activePaletteIndex];
      const color = palette[Math.floor(Math.random() * palette.length)].clone();
      const mat = new THREE.LineBasicMaterial({ color, linewidth: 4, transparent: true, opacity: 1 });
      const line = new THREE.Line(geo, mat);
      return { line, direction: dir, life: 2.5 };
    }

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.rotateSpeed = 0.5;
    controls.minDistance = 5;
    controls.maxDistance = 150;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.3;
    controls.enablePan = false;

    // Postprocessing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.6, 0.75);
    composer.addPass(bloomPass);
    const filmPass = new FilmPass(0.5, 0.7, 2048, false);
    composer.addPass(filmPass);
    composer.addPass(new OutputPass());

    // Pulsing ripples (2D canvas overlay) with color-matching to theme
    class Ripple {
      constructor(ctx, cx, cy, r, decay, color) {
        this.ctx = ctx;
        this.radius = 1;
        this.shadowRadius = 0;
        this.rSpeed = r;
        this.decay = decay;
        this.lineWidth = 12;
        this.epicenterX = cx;
        this.epicenterY = cy;
        this.killMe = false;
        this.opacity = 1;
        this.color = color; // THREE.Color
        this.colorStr = this.colorToRgba(this.color, 0.6);
        this.createSound();
      }
      colorToRgba(color, alpha) {
        const r = Math.round(color.r * 255);
        const g = Math.round(color.g * 255);
        const b = Math.round(color.b * 255);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }
      createSound() {
        // Pulse sound with subtle integration
        this.sound = new Pizzicato.Sound({
          source: 'wave',
          options: {
            volume: Math.min(this.epicenterY / window.innerHeight, 1.0),
            frequency: Math.max(100, Math.min(this.epicenterX * 2, 1000))
          }
        });
        const delay = new Pizzicato.Effects.DubDelay({
          feedback: 0.6, time: 0.8, mix: 0.5, cutoff: 600
        });
        this.sound.addEffect(delay);
      }
      update() {
        this.rDelta = this.rSpeed * this.decay;
        this.radius += this.rDelta;
        this.shadowRadius += this.rDelta;
        if (this.radius > 120) this.sound.stop();
        if (this.lineWidth > 1) this.lineWidth -= 0.4 * this.decay;
        if (this.radius > 300) this.opacity -= 0.08;
        if (this.radius > 450) this.killMe = true;
      }
      render() {
        const c = this.colorStr;
        const ctx = this.ctx;
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth + 3;
        ctx.strokeStyle = c;
        ctx.arc(this.epicenterX, this.epicenterY, this.shadowRadius, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth;
        ctx.strokeStyle = c;
        ctx.arc(this.epicenterX, this.epicenterY, this.radius, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.closePath();
      }
    }

    class Wave {
      constructor(cx, cy, color) {
        this.ripples = [];
        this.rippleSpeed = 15;
        this.rippleCount = 4;
        this.epicenterX = cx;
        this.epicenterY = cy;
        this.color = color;
        this.init();
      }
      init() {
        for (let i = 1; i <= this.rippleCount; i++) {
          const decay = Math.pow(0.7, i);
          const ripple = new Ripple(ctx, this.epicenterX, this.epicenterY, this.rippleSpeed, decay, this.color);
          this.ripples.push(ripple);
        }
        if (this.ripples.length > 0) this.ripples[0].sound.play();
      }
      destroyRipple(index) { this.ripples.splice(index, 1); }
      update() { for (let i = 0; i < this.ripples.length; i++) { this.ripples[i].update(); if (this.ripples[i].killMe) this.destroyRipple(i); } }
      render() { for (let i = 0; i < this.ripples.length; i++) { this.ripples[i].render(); } }
    }

    // Global pulse state
    const waves = [];
    let started = false;
    let msgOpacity = 1;

    // Node data structures
    class Node {
      constructor(position, level = 0, type = 0) {
        this.position = position;
        this.targetPosition = position.clone();
        this.connections = [];
        this.level = level;
        this.type = type;
        this.size = type === 0 ? THREE.MathUtils.randFloat(0.9, 1.5) : THREE.MathUtils.randFloat(0.6, 1.2);
        this.distanceFromRoot = 0;
        this.spiralIndex = 0;
        this.spiralPosition = 0;
        this.baseAngle = 0;
      }
      addConnection(node, strength = 1.0) {
        if (!this.isConnectedTo(node)) {
          this.connections.push({ node, strength });
          node.connections.push({ node: this, strength });
        }
      }
      isConnectedTo(node) { return this.connections.some(conn => conn.node === node); }
    }

    // Network generation (no Heart formation)
    function generateNeuralNetwork(formationIndex, densityFactor = 1.0) {
      let nodes = [];
      let rootNode;

      function generateWireframeCube() {
        rootNode = new Node(new THREE.Vector3(0,0,0), 0, 0);
        rootNode.size = 2.0;
        nodes.push(rootNode);
        const size = 25;
        const segments = Math.floor(25 * densityFactor);
        const vertices = [
          new THREE.Vector3(-size,-size,-size), new THREE.Vector3(size,-size,-size),
          new THREE.Vector3(size, size,-size), new THREE.Vector3(-size, size,-size),
          new THREE.Vector3(-size,-size, size), new THREE.Vector3(size,-size, size),
          new THREE.Vector3(size, size, size), new THREE.Vector3(-size, size, size)
        ];
        vertices.forEach((pos, i) => {
          const node = new Node(pos, 1, i % 2);
          node.distanceFromRoot = pos.length();
          nodes.push(node);
          rootNode.addConnection(node, 0.95);
        });
        const edges = [
          [0,1],[1,2],[2,3],[3,0], [4,5],[5,6],[6,7],[7,4],
          [0,4],[1,5],[2,6],[3,7]
        ];
        edges.forEach(([i,j]) => {
          const node1 = nodes[i+1], node2 = nodes[j+1];
          node1.addConnection(node2, 0.85);
          for (let s=1; s<segments; s++) {
            const t = s/segments;
            const pos = new THREE.Vector3().lerpVectors(node1.position, node2.position, t);
            const newNode = new Node(pos, 2, Math.random() < 0.5 ? 1 : 0);
            newNode.distanceFromRoot = pos.length();
            nodes.push(newNode);
            nodes[nodes.length-2].addConnection(newNode, 0.75);
            newNode.addConnection(node2, 0.75);
          }
        });
        for (let i = 1; i <= 8; i++) {
          for (let j = i+1; j <= 8; j++) {
            if (Math.random() < 0.4 * densityFactor) {
              nodes[i].addConnection(nodes[j], 0.65);
            }
          }
        }
        nodes[0].formationIndex = 0;
      }

      function generateSpiral() {
        rootNode = new Node(new THREE.Vector3(0,0,0), 0, 0);
        rootNode.size = 2.2;
        nodes.push(rootNode);
        const numSpirals = 10;
        const totalHeight = 50;
        const maxRadius = 25;
        const nodesPerSpiral = Math.floor(50 * densityFactor);
        const spiralNodes = [];
        for (let s = 0; s < numSpirals; s++) {
          const spiralPhase = (s / numSpirals) * Math.PI * 2;
          const spiralArray = [];
          for (let i = 0; i < nodesPerSpiral; i++) {
            const t = i / (nodesPerSpiral - 1);
            const height = (t - 0.5) * totalHeight;
            const radius = maxRadius * Math.sin(t * Math.PI);
            const revolutions = 4;
            const angle = spiralPhase + t * Math.PI * 2 * revolutions;
            const pos = new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle));
            pos.add(new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(2.5),
              THREE.MathUtils.randFloatSpread(2.5),
              THREE.MathUtils.randFloatSpread(2.5)
            ));
            const level = Math.floor(t * 8) + 1;
            const isLeaf = Math.random() < 0.5;
            const newNode = new Node(pos, level, isLeaf ? 1 : 0);
            newNode.distanceFromRoot = Math.sqrt(radius*radius + height*height);
            newNode.spiralIndex = s;
            newNode.spiralPosition = t;
            newNode.baseAngle = angle;
            nodes.push(newNode);
            spiralArray.push(newNode);
          }
          spiralNodes.push(spiralArray);
        }
        for (const spiral of spiralNodes) {
          rootNode.addConnection(spiral[0], 1.0);
          for (let i = 0; i < spiral.length-1; i++) {
            spiral[i].addConnection(spiral[i+1], 0.95);
          }
        }
        for (let s = 0; s < numSpirals; s++) {
          const currentSpiral = spiralNodes[s];
          const nextSpiral = spiralNodes[(s+1)%numSpirals];
          const connectionPoints = 10;
          for (let c = 0; c < connectionPoints; c++) {
            const t = c / (connectionPoints - 1);
            const idx1 = Math.floor(t * (currentSpiral.length - 1));
            const idx2 = Math.floor(t * (nextSpiral.length - 1));
            currentSpiral[idx1].addConnection(nextSpiral[idx2], 0.85);
          }
        }
        nodes[0].formationIndex = 1;
      }

      function generateDoubleHelix() {
        rootNode = new Node(new THREE.Vector3(0,0,0), 0, 0);
        rootNode.size = 2.0;
        nodes.push(rootNode);
        const strands = 2;
        const height = 50;
        const radius = 12;
        const nodesPerStrand = Math.floor(40 * densityFactor);
        const strandNodes = [];
        for (let s = 0; s < strands; s++) {
          const phase = s * Math.PI;
          const strand = [];
          for (let i = 0; i < nodesPerStrand; i++) {
            const t = i / (nodesPerStrand - 1);
            const y = (t - 0.5) * height;
            const angle = t * Math.PI * 6 + phase;
            const pos = new THREE.Vector3(radius * Math.cos(angle), y, radius * Math.sin(angle));
            pos.add(new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(2),
              THREE.MathUtils.randFloatSpread(2),
              THREE.MathUtils.randFloatSpread(2)
            ));
            const level = Math.floor(t * 8) + 1;
            const isLeaf = Math.random() < 0.5;
            const newNode = new Node(pos, level, isLeaf ? 1 : 0);
            newNode.distanceFromRoot = Math.sqrt(radius*radius + y*y);
            nodes.push(newNode);
            strand.push(newNode);
          }
          strandNodes.push(strand);
        }
        strandNodes.forEach(strand => {
          rootNode.addConnection(strand[0], 0.95);
          for (let i = 0; i < strand.length - 1; i++) {
            strand[i].addConnection(strand[i+1], 0.9);
          }
        });
        const crossConnections = Math.floor(20 * densityFactor);
        for (let i = 0; i < crossConnections; i++) {
          const t = i / (crossConnections - 1);
          const idx = Math.floor(t * (nodesPerStrand - 1));
          const node1 = strandNodes[0][idx];
          const node2 = strandNodes[1][idx];
          node1.addConnection(node2, 0.8);
        }
        nodes[0].formationIndex = 2;
      }

      function generateMandalas() {
        rootNode = new Node(new THREE.Vector3(0,0,0), 0, 0);
        rootNode.size = 2.0;
        nodes.push(rootNode);
        const layers = 6;
        const maxRadius = 30;
        const nodesPerLayer = Math.floor(35 * densityFactor);
        for (let layer = 1; layer <= layers; layer++) {
          const radius = maxRadius * (layer / layers);
          for (let i = 0; i < nodesPerLayer; i++) {
            const theta = (i / nodesPerLayer) * Math.PI * 2;
            const pos = new THREE.Vector3(
              radius * Math.cos(theta),
              0,
              radius * Math.sin(theta)
            );
            pos.add(new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(2),
              THREE.MathUtils.randFloatSpread(2),
              THREE.MathUtils.randFloatSpread(2)
            ));
            const isLeaf = Math.random() < 0.6;
            const newNode = new Node(pos, layer, isLeaf ? 1 : 0);
            newNode.distanceFromRoot = radius;
            nodes.push(newNode);
            if (layer === 1) {
              rootNode.addConnection(newNode, 0.95);
            } else {
              const prevLayerNodes = nodes.filter(n => n.level === layer - 1);
              const closest = prevLayerNodes.reduce((closest, n) => {
                const dist = n.position.distanceTo(pos);
                return dist < closest.dist ? { node: n, dist } : closest;
              }, { node: null, dist: Infinity }).node;
              if (closest) newNode.addConnection(closest, 0.85);
            }
          }
        }
        nodes[0].formationIndex = 3;
      }

      function generateBlackHole() {
        rootNode = new Node(new THREE.Vector3(0,0,0), 0, 0);
        rootNode.size = 2.5;
        nodes.push(rootNode);
        const rings = 8;
        const maxRadius = 35;
        const nodesPerRing = Math.floor(30 * densityFactor);
        for (let r = 1; r <= rings; r++) {
          const radius = maxRadius * (r / rings) * (0.7 + Math.random() * 0.3);
          for (let i = 0; i < nodesPerRing; i++) {
            const theta = (i / nodesPerRing) * Math.PI * 2 + Math.random() * 0.4;
            const pos = new THREE.Vector3(
              radius * Math.cos(theta),
              THREE.MathUtils.randFloatSpread(3),
              radius * Math.sin(theta)
            );
            const isLeaf = Math.random() < 0.7;
            const newNode = new Node(pos, r, isLeaf ? 1 : 0);
            newNode.distanceFromRoot = radius;
            nodes.push(newNode);
            if (r === 1) {
              rootNode.addConnection(newNode, 0.95);
            } else {
              const prevRingNodes = nodes.filter(n => n.level === r - 1);
              const closest = prevRingNodes.reduce((closest, n) => {
                const dist = n.position.distanceTo(pos);
                return dist < closest.dist ? { node: n, dist } : closest;
              }, { node: null, dist: Infinity }).node;
              if (closest) newNode.addConnection(closest, 0.85);
            }
            if (Math.random() < 0.5 * densityFactor) {
              const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
              if (randomNode !== newNode) newNode.addConnection(randomNode, 0.65);
            }
          }
        }
        nodes[0].formationIndex = 4;
      }

      function generateMovingSpiral() {
        rootNode = new Node(new THREE.Vector3(0,0,0), 0, 0);
        rootNode.size = 2.2;
        nodes.push(rootNode);
        const numSpirals = 8;
        const totalHeight = 45;
        const maxRadius = 22;
        const nodesPerSpiral = Math.floor(45 * densityFactor);
        const spiralNodes = [];
        for (let s = 0; s < numSpirals; s++) {
          const spiralPhase = (s / numSpirals) * Math.PI * 2;
          const spiralArray = [];
          for (let i = 0; i < nodesPerSpiral; i++) {
            const t = i / (nodesPerSpiral - 1);
            const height = (t - 0.5) * totalHeight;
            const radius = maxRadius * Math.sin(t * Math.PI);
            const angle = spiralPhase + t * Math.PI * 2 * 3;
            const pos = new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle));
            pos.add(new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(2),
              THREE.MathUtils.randFloatSpread(2),
              THREE.MathUtils.randFloatSpread(2)
            ));
            const level = Math.floor(t * 6) + 1;
            const isLeaf = Math.random() < 0.5 || i > nodesPerSpiral - 3;
            const newNode = new Node(pos, level, isLeaf ? 1 : 0);
            newNode.distanceFromRoot = Math.sqrt(radius*radius + height*height);
            newNode.spiralIndex = s;
            newNode.spiralPosition = t;
            newNode.baseAngle = angle;
            nodes.push(newNode);
            spiralArray.push(newNode);
          }
          spiralNodes.push(spiralArray);
        }
        for (const spiral of spiralNodes) {
          rootNode.addConnection(spiral[0], 1.0);
          for (let i = 0; i < spiral.length - 1; i++) {
            spiral[i].addConnection(spiral[i+1], 0.95);
          }
        }
        for (let s = 0; s < numSpirals; s++) {
          const currentSpiral = spiralNodes[s];
          const nextSpiral = spiralNodes[(s+1) % numSpirals];
          const connectionPoints = 8;
          for (let c = 0; c < connectionPoints; c++) {
            const t = c / (connectionPoints - 1);
            const idx1 = Math.floor(t * (currentSpiral.length - 1));
            const idx2 = Math.floor(t * (nextSpiral.length - 1));
            currentSpiral[idx1].addConnection(nextSpiral[idx2], 0.85);
          }
        }
        nodes[0].formationIndex = 5;
      }

      switch (formationIndex % config.numFormations) {
        case 0: generateWireframeCube(); break;
        case 1: generateSpiral(); break;
        case 2: generateDoubleHelix(); break;
        case 3: generateMandalas(); break;
        case 4: generateBlackHole(); break;
        case 5: generateMovingSpiral(); break;
      }

      // Density filtering (optional)
      if (densityFactor < 1.0) {
        const originalNodeCount = nodes.length;
        nodes = nodes.filter((node, index) => {
          if (node === rootNode) return true;
          const hash = (index * 31 + Math.floor(densityFactor * 100)) % 100;
          return hash < (densityFactor * 100);
        });
        nodes.forEach(n => { n.connections = n.connections.filter(conn => nodes.includes(conn.node)); });
        console.log(`Density Filter: ${originalNodeCount} -> ${nodes.length} nodes`);
      }

      return { nodes, rootNode };
    }

    let neuralNetwork = null, nodesMesh = null, connectionsMesh = null;
    // Pulse visuals
    const pulseUniforms = {
      uTime: { value: 0.0 },
      uPulsePositions: { value: [new THREE.Vector3(1e3,1e3,1e3), new THREE.Vector3(1e3,1e3,1e3), new THREE.Vector3(1e3,1e3,1e3)] },
      uPulseTimes: { value: [-1e3, -1e3, -1e3] },
      uPulseColors: { value: [new THREE.Color(1,1,1), new THREE.Color(1,1,1), new THREE.Color(1,1,1)] },
      uPulseSpeed: { value: 20.0 },
      uBaseNodeSize: { value: 0.7 },
      uActivePalette: { value: 0 },
      uTransitionProgress: { value: 0.0 },
      uBreatheScale: { value: 1.0 }
    };

    // Shaders (node + connections) (same as before, adjusted for this cleaned version)
    const noiseFunctions = `
// Simple 3D noise placeholder (kept for shader structure)
        float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
        vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
        float snoise(vec3 v){
            // Classic simplex-like permutation (kept lightweight)
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))
                                     + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                             + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec4 ox = floor(p * n_);
            vec4 ax = p - ox * n_;
            vec4 rx = abs(ax) + abs(ox);
            vec4 s = step(rx, vec4(1.0));
            vec4 fade = s * (1.0 - s);
            vec3 g0 = vec3(ax.x, ax.y, ax.z);
            vec3 g1 = vec3(ax.x, ax.y, ax.z);
            vec4 norm = taylorInvSqrt(vec4(dot(g0,g0), dot(g1,g1), dot(g0,g0), dot(g1,g1)));
            g0 *= norm.x;
            g1 *= norm.y;
            float contributions = 0.0;
            // Due to complexity, return small value; not used for major visuals here
            return contributions;
        }
        float fbm(vec3 p,float time){
            float value = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            int octaves = 4;
            for(int i=0;i<octaves;i++){
              value += amplitude * snoise(p*frequency + time*0.3*frequency);
              amplitude *= 0.5;
              frequency *= 2.0;
            }
            return value;
        }`;

    const nodeShader = {
      vertexShader: `${noiseFunctions}
      attribute float nodeSize; attribute float nodeType; attribute vec3 nodeColor; attribute vec3 connectionIndices; attribute float distanceFromRoot;
      attribute vec3 targetPosition;
      uniform float uTime; uniform vec3 uPulsePositions[3]; uniform float uPulseTimes[3]; uniform float uPulseSpeed; uniform float uBaseNodeSize;
      uniform float uTransitionProgress; uniform float uBreatheScale;
      varying vec3 vColor; varying float vNodeType; varying vec3 vPosition; varying float vPulseIntensity; varying float vDistanceFromRoot;

      float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime){
        if (pulseTime < 0.0) return 0.0;
        float timeSinceClick = uTime - pulseTime;
        if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;
        float pulseRadius = timeSinceClick * uPulseSpeed;
        float distToClick = distance(worldPos, pulsePos);
        float pulseThickness = 3.0;
        float waveProximity = abs(distToClick - pulseRadius);
        return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);
      }

      void main() {
        vNodeType = nodeType;
        vColor = nodeColor;
        vDistanceFromRoot = distanceFromRoot;

        vec3 modifiedPosition = mix(position, targetPosition, uTransitionProgress);
        modifiedPosition *= uBreatheScale;
        vec3 worldPos = (modelMatrix * vec4(modifiedPosition, 1.0)).xyz;
        vPosition = worldPos;

        float totalPulseIntensity = 0.0;
        for (int i = 0; i < 3; i++) {
          totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
        }
        vPulseIntensity = min(totalPulseIntensity, 1.0);

        float timeScale = 0.6 + 0.4 * sin(uTime * 1.0 + distanceFromRoot * 0.3);
        float baseSize = nodeSize * (0.9 + 0.3 * timeScale);
        float pulseSize = baseSize * (1.0 + vPulseIntensity * 3.0);

        // Use a simple directional offset to simulate a subtle dynamic
        vec3 dir = normalize(vec3(0.0, 1.0, 0.0));
        if (nodeType > 0.5) {
          float noise = fbm(modifiedPosition * 0.15, uTime * 0.2);
          modifiedPosition += dir * noise * 0.3;
        }

        vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);
        gl_PointSize = pulseSize * uBaseNodeSize * (1000.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }`,

      fragmentShader: `
      uniform float uTime; uniform vec3 uPulseColors[3]; uniform int uActivePalette;
      varying vec3 vColor; varying float vNodeType; varying vec3 vPosition; varying float vPulseIntensity; varying float vDistanceFromRoot;

      void main() {
        vec2 center = 2.0 * gl_PointCoord - 1.0;
        float dist = length(center);
        if (dist > 1.0) discard;

        float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);
        glowStrength = pow(glowStrength, 1.8);

        vec3 baseColor = vColor * (0.9 + 0.3 * sin(uTime * 0.7 + vDistanceFromRoot * 0.4));
        vec3 finalColor = baseColor;

        if (vPulseIntensity > 0.0) {
          vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.5);
          finalColor = mix(baseColor, pulseColor, vPulseIntensity);
          finalColor *= (1.0 + vPulseIntensity * 1.0);
        }

        float alpha = glowStrength * (1.0 - 0.5 * dist);
        float camDistance = length(vPosition - cameraPosition);
        float distanceFade = smoothstep(100.0, 20.0, camDistance);

        if (vNodeType > 0.5) {
          alpha *= 0.85;
        } else {
          finalColor *= 1.4;
        }

        gl_FragColor = vec4(finalColor, alpha * distanceFade);
      }`
    };

    const connectionShader = {
      vertexShader: `${noiseFunctions}
      attribute vec3 startPoint; attribute vec3 endPoint; attribute float connectionStrength; attribute float pathIndex; attribute vec3 connectionColor;
      attribute vec3 targetStartPoint; attribute vec3 targetEndPoint;
      uniform float uTime; uniform vec3 uPulsePositions[3]; uniform float uPulseTimes[3]; uniform float uPulseSpeed;
      uniform float uTransitionProgress; uniform float uBreatheScale;
      varying vec3 vColor; varying float vConnectionStrength; varying float vPulseIntensity; varying float vPathPosition;

      float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime){
        if (pulseTime < 0.0) return 0.0;
        float timeSinceClick = uTime - pulseTime;
        if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;
        float pulseRadius = timeSinceClick * uPulseSpeed;
        float distToClick = distance(worldPos, pulsePos);
        float pulseThickness = 3.0;
        float waveProximity = abs(distToClick - pulseRadius);
        return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);
      }

      void main() {
        float t = position.x;
        vPathPosition = t;

        vec3 start = mix(startPoint, targetStartPoint, uTransitionProgress);
        vec3 end = mix(endPoint, targetEndPoint, uTransitionProgress);
        start *= uBreatheScale;
        end *= uBreatheScale;
        vec3 midPoint = mix(start, end, 0.5);
        float pathOffset = sin(t * 3.14159) * 0.2;
        vec3 perpendicular = normalize(cross(normalize(end - start), vec3(0.0, 1.0, 0.0)));
        if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0);
        midPoint += perpendicular * pathOffset;

        vec3 p0 = mix(start, midPoint, t);
        vec3 p1 = mix(midPoint, end, t);
        vec3 finalPos = mix(p0, p1, t);

        float noiseTime = uTime * 0.3;
        float noise = fbm(vec3(pathIndex * 0.15, t * 0.7, noiseTime), noiseTime);
        finalPos += perpendicular * noise * 0.2;

        vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz;

        float totalPulseIntensity = 0.0;
        for (int i = 0; i < 3; i++) {
          totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);
        }
        vPulseIntensity = min(totalPulseIntensity, 1.0);

        vColor = connectionColor;
        vConnectionStrength = connectionStrength;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
      }`,
      fragmentShader: `
      uniform float uTime; uniform vec3 uPulseColors[3];
      varying vec3 vColor; varying float vConnectionStrength; varying float vPulseIntensity; varying float vPathPosition;

      void main() {
        vec3 baseColor = vColor * (0.8 + 0.4 * sin(uTime * 0.7 + vPathPosition * 15.0));
        float flowPattern = sin(vPathPosition * 30.0 - uTime * 5.0) * 0.5 + 0.5;
        float flowIntensity = 0.5 * flowPattern * vConnectionStrength;

        vec3 finalColor = baseColor;
        if (vPulseIntensity > 0.0) {
          vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.5);
          finalColor = mix(baseColor, pulseColor, vPulseIntensity);
          flowIntensity += vPulseIntensity * 0.7;
        }

        finalColor *= (0.8 + flowIntensity + vConnectionStrength * 0.6);
        float alpha = 0.9 * vConnectionStrength + 0.3 * flowPattern;
        alpha = mix(alpha, min(1.0, alpha * 2.5), vPulseIntensity);
        gl_FragColor = vec4(finalColor, alpha);
      }`
    };

    // Node and connection shaders are kept minimalistic and rely on above uniforms

    // Generate network visualization
    function createNetworkVisualization(formationIndex, densityFactor = 1.0, transition = true) {
      config.currentFormation = formationIndex;
      document.getElementById('formation-label').textContent = config.formationNames[formationIndex];

      if (!transition) {
        if (nodesMesh) {
          scene.remove(nodesMesh);
          nodesMesh.geometry.dispose();
          nodesMesh.material.dispose();
          nodesMesh = null;
        }
        if (connectionsMesh) {
          scene.remove(connectionsMesh);
          connectionsMesh.geometry.dispose();
          connectionsMesh.material.dispose();
          connectionsMesh = null;
        }
      }

      const newNetwork = generateNeuralNetwork(formationIndex, densityFactor);
      if (!newNetwork || newNetwork.nodes.length === 0) {
        console.error("Network generation failed or resulted in zero nodes.");
        return;
      }

      // If transition requested and there is a current network, set up transition target
      if (transition && neuralNetwork) {
        config.targetFormation = newNetwork;
        config.isTransitioning = true;
        config.transitionProgress = 0;

        newNetwork.nodes.forEach((newNode, i) => {
          const oldNode = neuralNetwork.nodes[i] || neuralNetwork.nodes[0];
          newNode.position.copy(oldNode.position);
          newNode.connections = oldNode.connections.map(conn => ({
            node: newNetwork.nodes[ neuralNetwork.nodes.indexOf(conn.node) ] || newNode,
            strength: conn.strength
          }));
        });
        neuralNetwork.nodes.forEach((node, i) => {
          node.targetPosition = newNetwork.nodes[i] ? newNetwork.nodes[i].position.clone() : node.position.clone();
        });
        return;
      }

      neuralNetwork = newNetwork;

      // Build node buffers
      const nodesGeometry = new THREE.BufferGeometry();
      const nodePositions = [], targetPositions = [], nodeTypes = [], nodeSizes = [], nodeColors = [], connectionIndices = [], distancesFromRoot = [];
      neuralNetwork.nodes.forEach((node) => {
        nodePositions.push(node.position.x, node.position.y, node.position.z);
        targetPositions.push(node.position.x, node.position.y, node.position.z);
        nodeTypes.push(node.type);
        nodeSizes.push(node.size);
        distancesFromRoot.push(node.distanceFromRoot);
        const indices = node.connections.slice(0, 3).map(conn => neuralNetwork.nodes.indexOf(conn.node));
        while (indices.length < 3) indices.push(-1);
        connectionIndices.push(...indices);
        const palette = colorPalettes[config.activePaletteIndex];
        const colorIndex = Math.min(node.level, palette.length - 1);
        const baseColor = palette[colorIndex % palette.length].clone();
        baseColor.offsetHSL(
          THREE.MathUtils.randFloatSpread(0.06),
          THREE.MathUtils.randFloatSpread(0.12),
          THREE.MathUtils.randFloatSpread(0.12)
        );
        nodeColors.push(baseColor.r, baseColor.g, baseColor.b);
      });
      nodesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions, 3));
      nodesGeometry.setAttribute('targetPosition', new THREE.Float32BufferAttribute(targetPositions, 3));
      nodesGeometry.setAttribute('nodeType', new THREE.Float32BufferAttribute(nodeTypes, 1));
      nodesGeometry.setAttribute('nodeSize', new THREE.Float32BufferAttribute(nodeSizes, 1));
      nodesGeometry.setAttribute('nodeColor', new THREE.Float32BufferAttribute(nodeColors, 3));
      nodesGeometry.setAttribute('connectionIndices', new THREE.Float32BufferAttribute(connectionIndices, 3));
      nodesGeometry.setAttribute('distanceFromRoot', new THREE.Float32BufferAttribute(distancesFromRoot, 1));

      const nodesMaterial = new THREE.ShaderMaterial({
        uniforms: THREE.UniformsUtils.clone(pulseUniforms),
        vertexShader: nodeShader.vertexShader,
        fragmentShader: nodeShader.fragmentShader,
        transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
      });

      nodesMesh = new THREE.Points(nodesGeometry, nodesMaterial);
      scene.add(nodesMesh);

      // Connections
      const connectionsGeometry = new THREE.BufferGeometry();
      const connectionColors = [], connectionStrengths = [], connectionPositions = [], startPoints = [], endPoints = [], targetStartPoints = [], targetEndPoints = [], pathIndices = [];
      const processedConnections = new Set();
      let pathIndex = 0;
      const numSegments = 20;

      neuralNetwork.nodes.forEach((node, nodeIndex) => {
        node.connections.forEach(connection => {
          const connectedNode = connection.node;
          const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
          if (connectedIndex === -1) return;
          const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
          if (!processedConnections.has(key)) {
            processedConnections.add(key);
            const startPoint = node.position;
            const endPoint = connectedNode.position;
            for (let i = 0; i < numSegments; i++) {
              const t = i / (numSegments - 1);
              connectionPositions.push(t, 0, 0);
              startPoints.push(startPoint.x, startPoint.y, startPoint.z);
              endPoints.push(endPoint.x, endPoint.y, endPoint.z);
              targetStartPoints.push(startPoint.x, startPoint.y, startPoint.z);
              targetEndPoints.push(endPoint.x, endPoint.y, endPoint.z);
              pathIndices.push(pathIndex);
              connectionStrengths.push(connection.strength);
              const palette = colorPalettes[config.activePaletteIndex];
              const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);
              const baseColor = palette[avgLevel % palette.length].clone();
              baseColor.offsetHSL(
                THREE.MathUtils.randFloatSpread(0.06),
                THREE.MathUtils.randFloatSpread(0.12),
                THREE.MathUtils.randFloatSpread(0.12)
              );
              connectionColors.push(baseColor.r, baseColor.g, baseColor.b);
            }
            pathIndex++;
          }
        });
      });

      connectionsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(connectionPositions, 3));
      connectionsGeometry.setAttribute('startPoint', new THREE.Float32BufferAttribute(startPoints, 3));
      connectionsGeometry.setAttribute('endPoint', new THREE.Float32BufferAttribute(endPoints, 3));
      connectionsGeometry.setAttribute('targetStartPoint', new THREE.Float32BufferAttribute(targetStartPoints, 3));
      connectionsGeometry.setAttribute('targetEndPoint', new THREE.Float32BufferAttribute(targetEndPoints, 3));
      connectionsGeometry.setAttribute('connectionStrength', new THREE.Float32BufferAttribute(connectionStrengths, 1));
      connectionsGeometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));
      connectionsGeometry.setAttribute('pathIndex', new THREE.Float32BufferAttribute(pathIndices, 1));

      const connectionsMaterial = new THREE.ShaderMaterial({
        uniforms: THREE.UniformsUtils.clone(pulseUniforms),
        vertexShader: connectionShader.vertexShader,
        fragmentShader: connectionShader.fragmentShader,
        transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
      });

      connectionsMesh = new THREE.LineSegments(connectionsGeometry, connectionsMaterial);
      scene.add(connectionsMesh);

      const palette = colorPalettes[config.activePaletteIndex];
      connectionsMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);
      connectionsMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);
      connectionsMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);
      nodesMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);
      nodesMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);
      nodesMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);
      nodesMaterial.uniforms.uActivePalette.value = config.activePaletteIndex;
    }

    // Theme update
    function updateTheme(paletteIndex) {
      config.activePaletteIndex = paletteIndex;
      if (!nodesMesh || !connectionsMesh || !starfield.points) return;
      const palette = colorPalettes[paletteIndex];

      const nodeColorsAttr = nodesMesh.geometry.attributes.nodeColor;
      for (let i = 0; i < nodeColorsAttr.count; i++) {
        const node = neuralNetwork.nodes[i];
        if (!node) continue;
        const colorIndex = Math.min(node.level, palette.length - 1);
        const baseColor = palette[colorIndex % palette.length].clone();
        baseColor.offsetHSL(
          THREE.MathUtils.randFloatSpread(0.06),
          THREE.MathUtils.randFloatSpread(0.12),
          THREE.MathUtils.randFloatSpread(0.12)
        );
        nodeColorsAttr.setXYZ(i, baseColor.r, baseColor.g, baseColor.b);
      }
      nodeColorsAttr.needsUpdate = true;

      // Rebuild color arrays for connections with a fresh palette
      const connectionColors = [];
      const processedConnections = new Set();
      const numSegments = 20;
      neuralNetwork.nodes.forEach((node, nodeIndex) => {
        node.connections.forEach(connection => {
          const connectedNode = connection.node;
          const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
          if (connectedIndex === -1) return;
          const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
          if (!processedConnections.has(key)) {
            processedConnections.add(key);
            for (let i = 0; i < numSegments; i++) {
              const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);
              const baseColor = palette[avgLevel % palette.length].clone();
              baseColor.offsetHSL(
                THREE.MathUtils.randFloatSpread(0.06),
                THREE.MathUtils.randFloatSpread(0.12),
                THREE.MathUtils.randFloatSpread(0.12)
              );
              connectionColors.push(baseColor.r, baseColor.g, baseColor.b);
            }
          }
        });
      });
      connectionsMesh.geometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));
      connectionsMesh.geometry.attributes.connectionColor.needsUpdate = true;

      // Pulse colors
      nodesMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));
      connectionsMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));
      nodesMesh.material.uniforms.uActivePalette.value = paletteIndex;

      // Update star colors
      const starColors = starfield.points.geometry.attributes.color;
      for (let i = 0; i < starColors.count; i++) {
        const color = palette[Math.floor(Math.random() * palette.length)].clone();
        color.offsetHSL(
          THREE.MathUtils.randFloatSpread(0.15),
          THREE.MathUtils.randFloatSpread(0.3),
          THREE.MathUtils.randFloatSpread(0.3)
        );
        starColors.setXYZ(i, color.r, color.g, color.b);
      }
      starColors.needsUpdate = true;

      // Update shooting stars colors
      starfield.shootingStars.forEach(star => {
        star.line.material.color.copy(palette[Math.floor(Math.random() * palette.length)]);
      });
    }

    // Interaction helpers for pulses
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    const interactionPoint = new THREE.Vector3();
    let lastPulseIndex = 0;

    function triggerPulse(clientX, clientY) {
      started = true;
      pointer.x = (clientX / window.innerWidth) * 2 - 1;
      pointer.y = -(clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      interactionPlane.normal.copy(camera.position).normalize();
      interactionPlane.constant = -interactionPlane.normal.dot(camera.position) + camera.position.length() * 0.5;
      if (raycaster.ray.intersectPlane(interactionPlane, interactionPoint)) {
        const time = clock.getElapsedTime();
        if (nodesMesh && connectionsMesh) {
          lastPulseIndex = (lastPulseIndex + 1) % 3;
          nodesMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint);
          nodesMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;
          connectionsMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(interactionPoint);
          connectionsMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;

          const palette = colorPalettes[config.activePaletteIndex];
          const randomColor = palette[Math.floor(Math.random() * palette.length)];
          nodesMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);
          connectionsMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);
        }
        // Draw ripple with the chosen color
        const colorForRipple = palette && palette.length ? palette[Math.floor(Math.random() * palette.length)] : colorPalettes[0][0];
        waves.push(new Wave(clientX * window.devicePixelRatio, clientY * window.devicePixelRatio, colorForRipple));
      }
    }

    // Event bindings
    const themeButtons = document.querySelectorAll('.theme-button');
    themeButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const idx = parseInt(btn.dataset.theme, 10);
        updateTheme(idx);
        themeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // Arrows under the theme modal
    document.getElementById('prev-formation').addEventListener('click', () => {
      goPrevFormation();
    });
    document.getElementById('next-formation').addEventListener('click', () => {
      goNextFormation();
    });

    // Density slider
    const densitySlider = document.getElementById('density-slider');
    const densityValue = document.getElementById('density-value');
    let densityTimeout;
    densitySlider.addEventListener('input', () => {
      const val = parseInt(densitySlider.value, 10);
      config.densityFactor = val / 100;
      densityValue.textContent = `${val}%`;
      clearTimeout(densityTimeout);
      densityTimeout = setTimeout(() => {
        createNetworkVisualization(config.currentFormation, config.densityFactor, false);
      }, 300);
    });

    // Keyboard navigation (1 and 2)
    window.addEventListener('keydown', (e) => {
      if (e.target.closest('.ui-panel')) return;
      if (!config.isTransitioning) {
        if (e.key === '1') { goPrevFormation(); }
        else if (e.key === '2') { goNextFormation(); }
      }
    });

    // Device orientation brains
    window.addEventListener('deviceorientation', (e) => {
      if (e.beta !== null && Math.abs(e.beta) > 60) {
        controls.reset();
        controls.autoRotate = false;
        setTimeout(() => { controls.autoRotate = true; }, 2000);
      }
    });

    function goPrevFormation() {
      if (config.isTransitioning) return;
      const nf = (config.currentFormation - 1 + config.numFormations) % config.numFormations;
      createNetworkVisualization(nf, config.densityFactor, true);
      controls.autoRotate = false;
      setTimeout(() => { controls.autoRotate = true; }, 4000);
    }

    function goNextFormation() {
      if (config.isTransitioning) return;
      const nf = (config.currentFormation + 1) % config.numFormations;
      createNetworkVisualization(nf, config.densityFactor, true);
      controls.autoRotate = false;
      setTimeout(() => { controls.autoRotate = true; }, 4000);
    }

    // Initialize visuals
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // Transitioning logic
      if (config.isTransitioning && neuralNetwork && config.targetFormation) {
        config.transitionProgress += 1 / (config.transitionDuration * 60);
        const easedProgress = easeInOutCubic(config.transitionProgress);
        if (config.transitionProgress >= 1) {
          config.transitionProgress = 0;
          config.isTransitioning = false;
          config.currentFormation = config.targetFormation.nodes[0].formationIndex || (config.currentFormation + 1) % config.numFormations;
          createNetworkVisualization(config.currentFormation, config.densityFactor, false);
        } else {
          // Blend positions
          const nodePositions = nodesMesh.geometry.attributes.position.array;
          neuralNetwork.nodes.forEach((node, i) => {
            const target = config.targetFormation.nodes[i] || config.targetFormation.nodes[0];
            nodePositions[i * 3] = THREE.MathUtils.lerp(node.position.x, target.position.x, easedProgress);
            nodePositions[i * 3 + 1] = THREE.MathUtils.lerp(node.position.y, target.position.y, easedProgress);
            nodePositions[i * 3 + 2] = THREE.MathUtils.lerp(node.position.z, target.position.z, easedProgress);
          });
          nodesMesh.geometry.attributes.position.needsUpdate = true;

          // Update connections
          const startArr = connectionsMesh.geometry.attributes.startPoint.array;
          const endArr = connectionsMesh.geometry.attributes.endPoint.array;
          const targetStartArr = connectionsMesh.geometry.attributes.targetStartPoint.array;
          const targetEndArr = connectionsMesh.geometry.attributes.targetEndPoint.array;
          const processedConnections = new Set();
          let connIndex = 0;
          neuralNetwork.nodes.forEach((node, nodeIndex) => {
            node.connections.forEach(connection => {
              const connectedNode = connection.node;
              const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
              if (connectedIndex === -1) return;
              const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
              if (!processedConnections.has(key)) {
                processedConnections.add(key);
                const targetNode1 = config.targetFormation.nodes[nodeIndex] || config.targetFormation.nodes[0];
                const targetNode2 = config.targetFormation.nodes[connectedIndex] || config.targetFormation.nodes[0];
                for (let i = 0; i < numSegments; i++) {
                  startArr[connIndex * 3] = THREE.MathUtils.lerp(startArr[connIndex * 3], targetNode1.position.x, easedProgress);
                  startArr[connIndex * 3 + 1] = THREE.MathUtils.lerp(startArr[connIndex * 3 + 1], targetNode1.position.y, easedProgress);
                  startArr[connIndex * 3 + 2] = THREE.MathUtils.lerp(startArr[connIndex * 3 + 2], targetNode1.position.z, easedProgress);

                  endArr[connIndex * 3] = THREE.MathUtils.lerp(endArr[connIndex * 3], targetNode2.position.x, easedProgress);
                  endArr[connIndex * 3 + 1] = THREE.MathUtils.lerp(endArr[connIndex * 3 + 1], targetNode2.position.y, easedProgress);
                  endArr[connIndex * 3 + 2] = THREE.MathUtils.lerp(endArr[connIndex * 3 + 2], targetNode2.position.z, easedProgress);

                  targetStartArr[connIndex * 3] = targetNode1.position.x;
                  targetStartArr[connIndex * 3 + 1] = targetNode1.position.y;
                  targetStartArr[connIndex * 3 + 2] = targetNode1.position.z;

                  targetEndArr[connIndex * 3] = targetNode2.position.x;
                  targetEndArr[connIndex * 3 + 1] = targetNode2.position.y;
                  targetEndArr[connIndex * 3 + 2] = targetNode2.position.z;

                  connIndex++;
                }
              }
            });
          });
          connectionsMesh.geometry.attributes.startPoint.needsUpdate = true;
          connectionsMesh.geometry.attributes.endPoint.needsUpdate = true;
          connectionsMesh.geometry.attributes.targetStartPoint.needsUpdate = true;
          connectionsMesh.geometry.attributes.targetEndPoint.needsUpdate = true;
        }
      }

      // Breathing scale for all
      config.breatheScale = 1.0 + 0.05 * Math.sin(t * 0.8);
      if (nodesMesh) nodesMesh.material.uniforms.uBreatheScale.value = config.breatheScale;
      if (connectionsMesh) connectionsMesh.material.uniforms.uBreatheScale.value = config.breatheScale;

      // Animate special formations
      if (neuralNetwork && neuralNetwork.nodes[0].formationIndex === 5) {
        // Moving spiral animation: reposition nodes
        const nodePositions = nodesMesh.geometry.attributes.position.array;
        neuralNetwork.nodes.forEach((node, i) => {
          if (node.spiralIndex !== undefined) {
            const angle = node.baseAngle + t * 0.2;
            const radius = 22 * Math.sin(node.spiralPosition * Math.PI);
            const height = (node.spiralPosition - 0.5) * 45;
            nodePositions[i * 3] = radius * Math.cos(angle);
            nodePositions[i * 3 + 1] = height;
            nodePositions[i * 3 + 2] = radius * Math.sin(angle);
          }
        });
        nodesMesh.geometry.attributes.position.needsUpdate = true;

        // Update connections endpoints accordingly
        let connIndex = 0;
        const processedConnections = new Set();
        const numSegments = 20;
        neuralNetwork.nodes.forEach((node, nodeIndex) => {
          node.connections.forEach(connection => {
            const connectedNode = connection.node;
            const connectedIndex = neuralNetwork.nodes.indexOf(connectedNode);
            if (connectedIndex === -1) return;
            const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');
            if (!processedConnections.has(key)) {
              processedConnections.add(key);
              const startNode = neuralNetwork.nodes[nodeIndex];
              const endNode = neuralNetwork.nodes[connectedIndex];
              for (let i = 0; i < numSegments; i++) {
                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3] = startNode.position.x;
                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 1] = startNode.position.y;
                connectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 2] = startNode.position.z;
                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3] = endNode.position.x;
                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 1] = endNode.position.y;
                connectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 2] = endNode.position.z;
                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3] = startNode.position.x;
                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3 + 1] = startNode.position.y;
                connectionsMesh.geometry.attributes.targetStartPoint.array[connIndex * 3 + 2] = startNode.position.z;
                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3] = endNode.position.x;
                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3 + 1] = endNode.position.y;
                connectionsMesh.geometry.attributes.targetEndPoint.array[connIndex * 3 + 2] = endNode.position.z;
                connIndex++;
              }
            }
          });
        });
        connectionsMesh.geometry.attributes.startPoint.needsUpdate = true;
        connectionsMesh.geometry.attributes.endPoint.needsUpdate = true;
        connectionsMesh.geometry.attributes.targetStartPoint.needsUpdate = true;
        connectionsMesh.geometry.attributes.targetEndPoint.needsUpdate = true;
      }

      // Pulse time uniform
      if (nodesMesh && connectionsMesh) {
        nodesMesh.material.uniforms.uTime.value = t;
        connectionsMesh.material.uniforms.uTime.value = t;
      }

      // Starfield motion and ripples
      const posArr = starfield.points.geometry.attributes.position.array;
      const velArr = starfield.points.geometry.attributes.velocity.array;
      for (let i = 0; i < posArr.length; i++) {
        posArr[i] += velArr[i] * 0.1;
        if (Math.abs(posArr[i]) > 200) posArr[i] *= -0.5;
      }
      starfield.points.geometry.attributes.position.needsUpdate = true;

      starfield.shootingStars = starfield.shootingStars.filter(s => s.life > 0);
      if (Math.random() < 0.02) {
        const ns = createShootingStar();
        scene.add(ns.line);
        starfield.shootingStars.push(ns);
      }
      starfield.shootingStars.forEach(star => {
        const positions = star.line.geometry.attributes.position.array;
        star.life -= 0.016;
        star.line.material.opacity = star.life / 2.5;
        for (let i = 0; i < 2; i++) {
          positions[i * 3] += star.direction.x * 5;
          positions[i * 3 + 1] += star.direction.y * 5;
          positions[i * 3 + 2] += star.direction.z * 5;
        }
        star.line.geometry.attributes.position.needsUpdate = true;
        if (star.life <= 0) {
          scene.remove(star.line);
          star.line.geometry.dispose();
          star.line.material.dispose();
        }
      });

      // Render
      composer.render();

      // 2D pulses
      ctx.clearRect(0, 0, ripplesCanvas.width, ripplesCanvas.height);
      waves.forEach(w => { w.update(); w.render(); });

      // Slight wake-up for breathing UI
      // no-op; breathing handled by CSS
    }

    // Resize handling
    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      composer.setSize(w, h);
      ripplesCanvas.width = w * Math.min(window.devicePixelRatio, 2);
      ripplesCanvas.height = h * Math.min(window.devicePixelRatio, 2);
      ripplesCanvas.style.width = w + 'px';
      ripplesCanvas.style.height = h + 'px';
    });

    // Init + start
    createNetworkVisualization(0, 1.0, false);
    // Watermark source already added in markup
    const clock = new THREE.Clock();
    animate();

    // UI wiring for density value text to reflect on demand
    const densityValueEl = document.getElementById('density-value');
  </script>
</body>
</html>