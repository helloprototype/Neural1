<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sonic Neural Network by ThePrototype.Live</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&display=swap" rel="stylesheet"/>

  <style>
    * { box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      font-family: 'Orbitron', system-ui, sans-serif;
      font-variant: small-caps;
      background: #000;
      overflow: hidden;
    }

    /* Magic wand cursor */

    :root {

      --wand-cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 64 64'%3E%3Cg fill='none' stroke='%23fff' stroke-width='3'%3E%3Cpath d='M10 54 L38 26'/%3E%3Cpath d='M41 23 l8 -8'/%3E%3C/g%3E%3Cg fill='none' stroke='%23ffd54a' stroke-width='3'%3E%3Cpath d='M45 5 v10'/%3E%3Cpath d='M50 10 h-10'/%3E%3Cpath d='M48 7 l-6 6'/%3E%3Cpath d='M48 13 l-6 -6'/%3E%3C/g%3E%3Ccircle cx='9' cy='55' r='3' fill='%23bbb'/%3E%3C/svg%3E") 2 2, auto;

    }

    body, canvas, .ui-panel, .theme-button, .legend, #watermark {

      cursor: var(--wand-cursor);

    }


    canvas {

      display: block;

      position: absolute;

      width: 100%;

      height: 100%;

      top: 0; left: 0;

    }

    #webgl-canvas { z-index: 1; }

    #ripples-canvas { z-index: 2; pointer-events: none; }



    @keyframes breathe {

      0%   { transform: translateY(0) scale(1); filter: brightness(1); }

      50%  { transform: translateY(-1px) scale(1.02); filter: brightness(1.05); }

      100% { transform: translateY(0) scale(1); filter: brightness(1); }

    }



    .ui-panel {

      position: absolute;

      top: 20px;

      right: 20px;

      z-index: 10;

      padding: 15px;

      display: flex; flex-direction: column; align-items: center; text-align: center;

      color: #eee;

      backdrop-filter: blur(10px);

      -webkit-backdrop-filter: blur(10px);

      background: rgba(0, 0, 0, .7);

      border-radius: 12px;

      border: 1px solid rgba(255, 120, 50, .3);

      box-shadow: 0 4px 20px rgba(0, 0, 0, .5);

      animation: breathe 6s ease-in-out infinite;

    }

    #theme-selector-title {

      font-weight: 600;

      font-size: 15px;

      margin-bottom: 10px;

    }

    #formation-label {

      font-size: 13px;

      margin-top: 10px;

      color: rgba(255, 120, 50, .9);

    }

    .theme-grid {

      display: grid;

      grid-template-columns: repeat(2, 1fr);

      gap: 10px;

      justify-items: center;

    }

    .theme-button {

      width: 36px; height: 36px;

      border-radius: 8px;

      border: 2px solid rgba(255, 255, 255, .3);

      transition: transform .2s, border-color .2s;

      outline: none; overflow: hidden;

      background: #333;

    }

    .theme-button:hover, .theme-button:focus {

      transform: scale(1.05);

      border-color: rgba(255, 255, 255, .7);

    }

    .theme-button.active {

      transform: scale(1.05);

      border-color: rgba(255, 255, 255, .9);

      box-shadow: 0 0 10px rgba(255, 200, 150, .6);

    }

    #theme-1 { background: linear-gradient(45deg, #4F46E5, #7C3AED, #C026D3, #DB2777); }

    #theme-2 { background: linear-gradient(45deg, #F59E0B, #F97316, #DC2626, #7F1D1D); }

    #theme-3 { background: linear-gradient(45deg, #EC4899, #8B5CF6, #6366F1, #3B82F6); }

    #theme-4 { background: linear-gradient(45deg, #10B981, #A3E635, #FACC15, #FB923C); }



    #density-controls {

      margin-top: 12px;

      display: flex; flex-direction: column; gap: 8px;

      width: 100%;

    }

    .density-label {

      font-size: 13px;

      display: flex; justify-content: space-between;

    }

    .density-slider {

      width: 100%;

      appearance: none;

      height: 4px; border-radius: 2px;

      background: rgba(255, 120, 50, .3);

      outline: none; cursor: pointer;

    }

    .density-slider::-webkit-slider-thumb {

      appearance: none;

      width: 14px; height: 14px; border-radius: 50%;

      background: rgba(255, 120, 50, .8);

      transition: transform .1s, background .1s;

    }

    .density-slider::-webkit-slider-thumb:hover { transform: scale(1.1); background: rgba(255, 140, 50, 1); }

    .density-slider::-moz-range-thumb {

      width: 14px; height: 14px; border-radius: 50%;

      background: rgba(255, 120, 50, .8);

      border: none;

      transition: transform .1s, background .1s;

    }

    .density-slider::-moz-range-thumb:hover { transform: scale(1.1); background: rgba(255, 140, 50, 1); }



    .legend {

      pointer-events: none;

      position: absolute; top: 10px; left: 25px;

      color: white; z-index: 10;

    }

    .legend p {

      margin: 0;

      text-transform: uppercase;

      letter-spacing: 5px;

      font-size: 12px;

      user-select: none;

      position: relative;

    }

    .legend p.vert {

      margin-top: 10px; left: -20px;

      writing-mode: vertical-lr; text-orientation: upright;

    }



    /* Watermark bottom-center with breathing */

    #watermark {

      position: absolute;

      left: 50%;

      transform: translateX(-50%);

      bottom: clamp(16px, 5vh, 48px);

      width: clamp(90px, 12vw, 180px);

      opacity: 0.9;

      z-index: 12;

      pointer-events: none;

      animation: breathe 7.5s ease-in-out infinite;

      filter: drop-shadow(0 2px 8px rgba(0,0,0,.6));

    }



    @media (max-width: 640px) {

      .ui-panel { top: auto; right: 10px; bottom: 20px; max-width: 140px; padding: 10px; }

      #theme-selector-title, #formation-label { font-size: 14px; }

      .theme-button { width: 30px; height: 30px; }

      .density-label { font-size: 12px; }

    }

    @media (max-width: 400px) {

      .ui-panel {

        width: calc(100% - 20px);

        left: 10px; right: 10px; bottom: 20px;

      }

      .theme-grid { grid-template-columns: repeat(4, 1fr); }

      #density-controls { width: 80%; margin-top: 15px; }

    }

  </style>

</head>

<body>

  <div id="theme-selector" class="ui-panel">

    <div id="theme-selector-title">Visual Theme</div>

    <div class="theme-grid">

      <button class="theme-button active" id="theme-1" data-theme="0" aria-label="Theme 1"></button>

      <button class="theme-button" id="theme-2" data-theme="1" aria-label="Theme 2"></button>

      <button class="theme-button" id="theme-3" data-theme="2" aria-label="Theme 3"></button>

      <button class="theme-button" id="theme-4" data-theme="3" aria-label="Theme 4"></button>

    </div>

    <div id="density-controls">

      <div class="density-label"><span>Density</span><span id="density-value">100%</span></div>

      <input type="range" min="20" max="100" value="100" class="density-slider" id="density-slider" aria-label="Network Density">

    </div>

    <div id="formation-label">Cube</div>

  </div>



  <div class="legend">

    <p>Pitch</p>

    <p class="vert">Volume</p>

  </div>



  <canvas id="webgl-canvas"></canvas>

  <canvas id="ripples-canvas"></canvas>



  <img id="watermark" alt="Paradox Uni" src="https://paradoxuni.b-cdn.net/!File%20Organization/!PROTOTYPE/ProtoLogo.png"/>



  <script src="https://cdnjs.cloudflare.com/ajax/libs/pizzicato/0.6.4/Pizzicato.min.js"></script>

  <script type="importmap">

  {

    "imports": {

      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",

      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"

    }

  }

  </script>



  <script type="module">

    import * as THREE from 'three';

    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';

    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';



    const easingUtils = {

      easeInOutCubic: (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2)

    };



    const config = {

      activePaletteIndex: 0,

      currentFormation: 0,

      numFormations: 8, // Cube, Double Helix, Mandalas, Black Hole, Metatron, Flower of Life, Torus Knot, Moving Spiral

      densityFactor: 1,

      isTransitioning: false,

      transitionProgress: 0,

      transitionDuration: 2.8,

      breatheScale: 1,

      formationNames: [

        'Cube',

        'Double Helix',

        'Mandalas',

        'Black Hole',

        'Metatron',

        'Flower of Life',

        'Torus Knot',

        'Moving Spiral'

      ]

    };



    const colorPalettes = [

      [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)],

      [new THREE.Color(0xF59E0B), new THREE.Color(0xF97316), new THREE.Color(0xDC2626), new THREE.Color(0x7F1D1D), new THREE.Color(0xFBBF24)],

      [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)],

      [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)]

    ];



    // Scene

    const scene = new THREE.Scene();

    scene.fog = new THREE.FogExp2(0x000000, 0.001);



    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);

    camera.position.set(0, 5, 25);



    const webglCanvas = document.getElementById('webgl-canvas');

    const overlayCanvas = document.getElementById('ripples-canvas');

    const ctx = overlayCanvas.getContext('2d');



    const renderer = new THREE.WebGLRenderer({ canvas: webglCanvas, antialias: true, powerPreference: 'high-performance' });

    renderer.setSize(window.innerWidth, window.innerHeight);

    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    renderer.setClearColor(0x000000);

    renderer.outputColorSpace = THREE.SRGBColorSpace;



    const render = {

      width: window.innerWidth, height: window.innerHeight,

      hWidth: window.innerWidth * 0.5, hHeight: window.innerHeight * 0.5,

      dpi: window.devicePixelRatio

    };

    overlayCanvas.width = render.width * render.dpi;

    overlayCanvas.height = render.height * render.dpi;



    // Starfield

    function createStarfield() {

      const count = 15000, pos = [], colors = [], velocities = [];

      const palette = colorPalettes[config.activePaletteIndex];

      for (let i = 0; i < count; i++) {

        const r = THREE.MathUtils.randFloat(50, 200);

        const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));

        const theta = THREE.MathUtils.randFloat(0, Math.PI * 2);

        pos.push(

          r * Math.sin(phi) * Math.cos(theta),

          r * Math.sin(phi) * Math.sin(theta),

          r * Math.cos(phi)

        );

        const color = palette[Math.floor(Math.random() * palette.length)].clone();

        color.offsetHSL(THREE.MathUtils.randFloatSpread(0.15), THREE.MathUtils.randFloatSpread(0.3), THREE.MathUtils.randFloatSpread(0.3));

        colors.push(color.r, color.g, color.b);

        velocities.push(

          THREE.MathUtils.randFloatSpread(0.1),

          THREE.MathUtils.randFloatSpread(0.1),

          THREE.MathUtils.randFloatSpread(0.1)

        );

      }

      const geo = new THREE.BufferGeometry();

      geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

      geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

      const mat = new THREE.PointsMaterial({ size: 0.25, sizeAttenuation: true, depthWrite: false, opacity: 0.85, transparent: true, vertexColors: true });

      return { points: new THREE.Points(geo, mat), shootingStars: [] };

    }

    const starfield = createStarfield();

    scene.add(starfield.points);



    function createShootingStar() {

      const pos = new THREE.Vector3(

        THREE.MathUtils.randFloatSpread(200),

        THREE.MathUtils.randFloatSpread(200),

        THREE.MathUtils.randFloatSpread(200)

      );

      const dir = new THREE.Vector3(

        THREE.MathUtils.randFloatSpread(1),

        THREE.MathUtils.randFloatSpread(1),

        THREE.MathUtils.randFloatSpread(1)

      ).normalize();

      const geo = new THREE.BufferGeometry();

      const positions = [pos.x, pos.y, pos.z, pos.x + dir.x * 4, pos.y + dir.y * 4, pos.z + dir.z * 4];

      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

      const palette = colorPalettes[config.activePaletteIndex];

      const color = palette[Math.floor(Math.random() * palette.length)].clone();

      const mat = new THREE.LineBasicMaterial({ color, linewidth: 4, transparent: true, opacity: 1 });

      const line = new THREE.Line(geo, mat);

      return { line, direction: dir, life: 2.5 };

    }



    // Controls

    const controls = new OrbitControls(camera, renderer.domElement);

    controls.enableDamping = true;

    controls.dampingFactor = 0.05;

    controls.rotateSpeed = 0.5;

    controls.minDistance = 5;

    controls.maxDistance = 150;

    controls.autoRotate = true;

    controls.autoRotateSpeed = 0.3;

    controls.enablePan = false;



    // Postprocessing

    const composer = new EffectComposer(renderer);

    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.6, 0.6, 0.75);

    composer.addPass(bloomPass);

    const filmPass = new FilmPass(0.5, 0.7, 2048, false);

    composer.addPass(filmPass);

    composer.addPass(new OutputPass());



    // Ripples

    class Wave {

      constructor(cx, cy) {

        this.ripples = [];

        this.rippleSpeed = 15;

        this.rippleCount = 5;

        this.epicenterX = cx;

        this.epicenterY = cy;

        this.init();

      }

      init() {

        for (let i = 1; i <= this.rippleCount; i++) {

          const decay = Math.pow(0.7, i);

          const ripple = new Ripple(ctx, this.epicenterX, this.epicenterY, this.rippleSpeed, decay);

          this.ripples.push(ripple);

        }

        this.ripples[0].sound.play();

      }

      destroyRipple(index) { this.ripples.splice(index, 1); }

      update() {

        for (let i = 0; i < this.ripples.length; i++) {

          this.ripples[i].update();

          if (this.ripples[i].killMe) this.destroyRipple(i);

        }

      }

      render() { for (let i = 0; i < this.ripples.length; i++) this.ripples[i].render(); }

    }

    class Ripple {

      constructor(ctx, cx, cy, r, decay) {

        this.ctx = ctx;

        this.radius = 1;

        this.shadowRadius = 0;

        this.rSpeed = r;

        this.decay = decay;

        this.lineWidth = 16; // more dramatic

        this.epicenterX = cx;

        this.epicenterY = cy;

        this.killMe = false;

        this.opacity = 1;

        this.createSound();

      }

      createSound() {

        this.sound = new Pizzicato.Sound({

          source: 'wave',

          options: {

            volume: Math.min(this.epicenterY / render.height, 1.0),

            frequency: Math.max(100, Math.min(this.epicenterX * 2, 1000))

          }

        });

        const delay = new Pizzicato.Effects.DubDelay({ feedback: 0.6, time: 0.8, mix: 0.5, cutoff: 600 });

        this.sound.addEffect(delay);

      }

      update() {

        this.rDelta = this.rSpeed * this.decay;

        this.radius += this.rDelta;

        this.shadowRadius += this.rDelta;

        if (this.radius > 120) this.sound.stop();

        if (this.lineWidth > 1) this.lineWidth -= 0.4 * this.decay;

        if (this.radius > 320) this.opacity -= 0.06; // longer presence

        if (this.radius > 460) this.killMe = true;

      }

      render() {

        const ctx = this.ctx;

        ctx.beginPath();

        ctx.lineWidth = this.lineWidth + 3;

        ctx.strokeStyle = `hsla(33,97%,49%,${this.opacity * 0.85})`;

        ctx.arc(this.epicenterX, this.epicenterY, this.shadowRadius, 0, 2 * Math.PI);

        ctx.stroke();

        ctx.closePath();

        ctx.beginPath();

        ctx.lineWidth = this.lineWidth;

        ctx.strokeStyle = `hsla(255, 255%, 255%, ${this.opacity})`;

        ctx.arc(this.epicenterX, this.epicenterY, this.radius, 0, 2 * Math.PI);

        ctx.stroke();

        ctx.closePath();

      }

    }

    const waves = [];

    let started = false;



    // Shaders

    const noiseFunctions = `

      vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}

      vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}

      vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}

      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}

      float snoise(vec3 v){

        const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);

        vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);

        vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);

        vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);

        vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));

        float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;

        vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);

        vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);

        vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;

        vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;

        vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);

        vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));

        p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);

        m*=m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));

      }

      float fbm(vec3 p,float time){

        float value=0.0;float amplitude=0.5;float frequency=1.0;int octaves=4;

        for(int i=0;i<octaves;i++){

          value+=amplitude*snoise(p*frequency+time*0.3*frequency);

          amplitude*=0.5;frequency*=2.0;

        }

        return value;

      }

    `;



    const nodeShader = {

      vertexShader: `${noiseFunctions}

        attribute float nodeSize;

        attribute float nodeType;

        attribute vec3 nodeColor;

        attribute float distanceFromRoot;



        uniform float uTime;

        uniform vec3 uPulsePositions[3];

        uniform float uPulseTimes[3];

        uniform float uPulseSpeed;

        uniform float uBaseNodeSize;

        uniform float uBreatheScale;



        varying vec3 vColor;

        varying float vNodeType;

        varying vec3 vPosition;

        varying float vPulseIntensity;

        varying float vDistanceFromRoot;



        float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {

          if (pulseTime < 0.0) return 0.0;

          float timeSinceClick = uTime - pulseTime;

          if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;

          float pulseRadius = timeSinceClick * uPulseSpeed;

          float distToClick = distance(worldPos, pulsePos);

          float pulseThickness = 3.0;

          float waveProximity = abs(distToClick - pulseRadius);

          return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);

        }



        void main() {

          vNodeType = nodeType;

          vColor = nodeColor;

          vDistanceFromRoot = distanceFromRoot;



          vec3 modifiedPosition = position * uBreatheScale;



          vec3 worldPos = (modelMatrix * vec4(modifiedPosition, 1.0)).xyz;

          vPosition = worldPos;



          float totalPulseIntensity = 0.0;

          for (int i = 0; i < 3; i++) {

            totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);

          }

          vPulseIntensity = min(totalPulseIntensity, 1.0);



          float timeScale = 0.6 + 0.4 * sin(uTime * 1.0 + distanceFromRoot * 0.3);

          float baseSize = nodeSize * (0.9 + 0.3 * timeScale);

          float pulseSize = baseSize * (1.0 + vPulseIntensity * 6.0);



          if (nodeType > 0.5) {

            vec3 dir = normalize(modifiedPosition + vec3(0.0001));

            float noise = fbm(modifiedPosition * 0.15, uTime * 0.2);

            modifiedPosition += dir * noise * 0.3;

          }



          vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);

          gl_PointSize = pulseSize * uBaseNodeSize * (1000.0 / -mvPosition.z);

          gl_Position = projectionMatrix * mvPosition;

        }

      `,

      fragmentShader: `

        uniform float uTime;

        uniform vec3 uPulseColors[3];

        uniform int uActivePalette;

        uniform float uGlobalOpacity;



        varying vec3 vColor;

        varying float vNodeType;

        varying vec3 vPosition;

        varying float vPulseIntensity;

        varying float vDistanceFromRoot;



        void main() {

          vec2 center = 2.0 * gl_PointCoord - 1.0;

          float dist = length(center);

          if (dist > 1.0) discard;



          float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);

          glowStrength = pow(glowStrength, 1.8);



          vec3 baseColor = vColor * (0.9 + 0.3 * sin(uTime * 0.7 + vDistanceFromRoot * 0.4));

          vec3 finalColor = baseColor;



          if (vPulseIntensity > 0.0) {

            vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.5);

            finalColor = mix(baseColor, pulseColor, vPulseIntensity);

            finalColor *= (1.0 + vPulseIntensity * 1.6);

          }



          float alpha = glowStrength * (1.0 - 0.5 * dist);

          float camDistance = length(vPosition - cameraPosition);

          float distanceFade = smoothstep(100.0, 20.0, camDistance);



          if (vNodeType > 0.5) {

            alpha *= 0.85;

          } else {

            finalColor *= 1.4;

          }



          gl_FragColor = vec4(finalColor, alpha * distanceFade * uGlobalOpacity);

        }

      `

    };



    const connectionShader = {

      vertexShader: `${noiseFunctions}

        attribute vec3 startPoint;

        attribute vec3 endPoint;

        attribute float connectionStrength;

        attribute float pathIndex;

        attribute vec3 connectionColor;



        uniform float uTime;

        uniform vec3 uPulsePositions[3];

        uniform float uPulseTimes[3];

        uniform float uPulseSpeed;

        uniform float uBreatheScale;



        varying vec3 vColor;

        varying float vConnectionStrength;

        varying float vPulseIntensity;

        varying float vPathPosition;



        float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {

          if (pulseTime < 0.0) return 0.0;

          float timeSinceClick = uTime - pulseTime;

          if (timeSinceClick < 0.0 || timeSinceClick > 4.0) return 0.0;

          float pulseRadius = timeSinceClick * uPulseSpeed;

          float distToClick = distance(worldPos, pulsePos);

          float pulseThickness = 3.0;

          float waveProximity = abs(distToClick - pulseRadius);

          return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(4.0, 0.0, timeSinceClick);

        }



        void main() {

          float t = position.x;

          vPathPosition = t;



          vec3 start = startPoint * uBreatheScale;

          vec3 end = endPoint * uBreatheScale;



          vec3 midPoint = mix(start, end, 0.5);

          float pathOffset = sin(t * 3.14159) * 0.2;

          vec3 perpendicular = normalize(cross(normalize(end - start), vec3(0.0, 1.0, 0.0)));

          if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0);

          midPoint += perpendicular * pathOffset;



          vec3 p0 = mix(start, midPoint, t);

          vec3 p1 = mix(midPoint, end, t);

          vec3 finalPos = mix(p0, p1, t);



          float noiseTime = uTime * 0.3;

          float noise = fbm(vec3(pathIndex * 0.15, t * 0.7, noiseTime), noiseTime);

          finalPos += perpendicular * noise * 0.2;



          vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz;



          float totalPulseIntensity = 0.0;

          for (int i = 0; i < 3; i++) {

            totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);

          }

          vPulseIntensity = min(totalPulseIntensity, 1.0);



          vColor = connectionColor;

          vConnectionStrength = connectionStrength;



          gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);

        }

      `,

      fragmentShader: `

        uniform float uTime;

        uniform vec3 uPulseColors[3];

        uniform float uGlobalOpacity;



        varying vec3 vColor;

        varying float vConnectionStrength;

        varying float vPulseIntensity;

        varying float vPathPosition;



        void main() {

          vec3 baseColor = vColor * (0.8 + 0.4 * sin(uTime * 0.7 + vPathPosition * 15.0));

          float flowPattern = sin(vPathPosition * 30.0 - uTime * 5.0) * 0.5 + 0.5;

          float flowIntensity = 0.5 * flowPattern * vConnectionStrength;



          vec3 finalColor = baseColor;



          if (vPulseIntensity > 0.0) {

            vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.5);

            finalColor = mix(baseColor, pulseColor, vPulseIntensity);

            flowIntensity += vPulseIntensity * 1.1;

          }



          finalColor *= (0.9 + flowIntensity + vConnectionStrength * 0.8);



          float alpha = 0.9 * vConnectionStrength + 0.3 * flowPattern;

          alpha = mix(alpha, min(1.0, alpha * 2.5), vPulseIntensity);



          gl_FragColor = vec4(finalColor, alpha * uGlobalOpacity);

        }

      `

    };



    const pulseUniforms = {

      uTime: { value: 0.0 },

      uPulsePositions: { value: [new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3)] },

      uPulseTimes: { value: [-1e3, -1e3, -1e3] },

      uPulseColors: { value: [new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1)] },

      uPulseSpeed: { value: 28.0 },

      uBaseNodeSize: { value: 0.7 },

      uActivePalette: { value: 0 },

      uBreatheScale: { value: 1.0 },

      uGlobalOpacity: { value: 1.0 }

    };



    // Data model

    class Node {

      constructor(position, level = 0, type = 0) {

        this.position = position;

        this.level = level;

        this.type = type;

        this.size = type === 0 ? THREE.MathUtils.randFloat(0.9, 1.5) : THREE.MathUtils.randFloat(0.6, 1.2);

        this.distanceFromRoot = 0;

        this.connections = [];

        // For moving spiral

        this.spiralIndex = 0;

        this.spiralPosition = 0;

        this.baseAngle = 0;

      }

      addConnection(node, strength = 1.0) {

        if (!this.isConnectedTo(node)) {

          this.connections.push({ node, strength });

          node.connections.push({ node: this, strength });

        }

      }

      isConnectedTo(node) { return this.connections.some(c => c.node === node); }

    }



    // Sacred geometry embellishment

    function embellishSacredGeometry(nodes, densityFactor = 1.0, addMicros = true) {

      // Connect angular neighbors on same level for hex/star feel

      const byLevel = new Map();

      for (const n of nodes) {

        const arr = byLevel.get(n.level) || [];

        arr.push(n);

        byLevel.set(n.level, arr);

      }

      byLevel.forEach(levelNodes => {

        if (levelNodes.length < 4) return;

        const c = levelNodes.reduce((acc, n) => acc.add(n.position.clone()), new THREE.Vector3()).multiplyScalar(1 / levelNodes.length);

        levelNodes.sort((a, b) =>

          Math.atan2(a.position.z - c.z, a.position.x - c.x) - Math.atan2(b.position.z - c.z, b.position.x - c.x)

        );

        const steps = [1, 2, 3];

        for (let i = 0; i < levelNodes.length; i++) {

          for (const s of steps) {

            if (Math.random() < 0.35 * densityFactor) {

              const j = (i + s) % levelNodes.length;

              levelNodes[i].addConnection(levelNodes[j], 0.7);

            }

          }

        }

      });



      if (!addMicros) return;



      // Micro-nodes along connections

      const extraSegments = Math.floor(nodes.length * 0.12 * densityFactor);

      let created = 0;

      const pairs = [];

      nodes.forEach(n => n.connections.forEach(c => pairs.push([n, c.node, c.strength])));

      for (let k = 0; k < pairs.length && created < extraSegments; k++) {

        if (Math.random() < 0.25) {

          const [a, b, strength] = pairs[k];

          const t = THREE.MathUtils.randFloat(0.3, 0.7);

          const pos = new THREE.Vector3().lerpVectors(a.position, b.position, t)

            .add(new THREE.Vector3(

              THREE.MathUtils.randFloatSpread(0.8),

              THREE.MathUtils.randFloatSpread(0.8),

              THREE.MathUtils.randFloatSpread(0.8)

            ));

          const m = new Node(pos, Math.min(a.level, b.level) + 1, Math.random() < 0.6 ? 1 : 0);

          m.distanceFromRoot = pos.length();

          nodes.push(m);

          a.addConnection(m, Math.min(1, strength + 0.05));

          m.addConnection(b, Math.min(1, strength + 0.05));

          created++;

        }

      }

    }



    // Formation generators

    function generateWireframeCube() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.0;

      nodes.push(rootNode);



      const size = 25;

      const segments = Math.floor(25 * config.densityFactor);

      const vertices = [

        new THREE.Vector3(-size, -size, -size), new THREE.Vector3(size, -size, -size),

        new THREE.Vector3(size, size, -size), new THREE.Vector3(-size, size, -size),

        new THREE.Vector3(-size, -size, size), new THREE.Vector3(size, -size, size),

        new THREE.Vector3(size, size, size), new THREE.Vector3(-size, size, size)

      ];

      vertices.forEach((pos, i) => {

        const node = new Node(pos, 1, i % 2);

        node.distanceFromRoot = pos.length();

        nodes.push(node);

        rootNode.addConnection(node, 0.95);

      });

      const edges = [

        [0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4],

        [0, 4], [1, 5], [2, 6], [3, 7]

      ];

      edges.forEach(([i, j]) => {

        const node1 = nodes[i + 1], node2 = nodes[j + 1];

        node1.addConnection(node2, 0.85);

        for (let s = 1; s < segments; s++) {

          const t = s / segments;

          const pos = new THREE.Vector3().lerpVectors(node1.position, node2.position, t);

          const newNode = new Node(pos, 2, Math.random() < 0.5 ? 1 : 0);

          newNode.distanceFromRoot = pos.length();

          nodes.push(newNode);

          nodes[nodes.length - 2].addConnection(newNode, 0.75);

          newNode.addConnection(node2, 0.75);

        }

      });

      for (let i = 1; i <= 8; i++) {

        for (let j = i + 1; j <= 8; j++) {

          if (Math.random() < 0.4 * config.densityFactor) nodes[i].addConnection(nodes[j], 0.65);

        }

      }



      embellishSacredGeometry(nodes, config.densityFactor, true);

      nodes[0].formationIndex = 0;

      return { nodes, rootNode };

    }



    function generateDoubleHelix() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.0;

      nodes.push(rootNode);



      const strands = 2;

      const height = 50;

      const radius = 12;

      const nodesPerStrand = Math.floor(40 * config.densityFactor);

      const strandNodes = [];



      for (let s = 0; s < strands; s++) {

        const phase = s * Math.PI;

        const strand = [];

        for (let i = 0; i < nodesPerStrand; i++) {

          const t = i / (nodesPerStrand - 1);

          const y = (t - 0.5) * height;

          const angle = t * Math.PI * 6 + phase;

          const pos = new THREE.Vector3(radius * Math.cos(angle), y, radius * Math.sin(angle))

            .add(new THREE.Vector3(

              THREE.MathUtils.randFloatSpread(2),

              THREE.MathUtils.randFloatSpread(2),

              THREE.MathUtils.randFloatSpread(2)

            ));

          const level = Math.floor(t * 8) + 1;

          const newNode = new Node(pos, level, Math.random() < 0.5 ? 1 : 0);

          newNode.distanceFromRoot = Math.sqrt(radius * radius + y * y);

          nodes.push(newNode);

          strand.push(newNode);

        }

        strandNodes.push(strand);

      }

      strandNodes.forEach(strand => {

        rootNode.addConnection(strand[0], 0.95);

        for (let i = 0; i < strand.length - 1; i++) {

          strand[i].addConnection(strand[i + 1], 0.9);

        }

      });

      const crossConnections = Math.floor(20 * config.densityFactor);

      for (let i = 0; i < crossConnections; i++) {

        const t = i / (crossConnections - 1);

        const idx = Math.floor(t * (nodesPerStrand - 1));

        const node1 = strandNodes[0][idx];

        const node2 = strandNodes[1][idx];

        node1.addConnection(node2, 0.8);

      }



      embellishSacredGeometry(nodes, config.densityFactor, true);

      nodes[0].formationIndex = 1;

      return { nodes, rootNode };

    }



    function generateMandalas() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.0;

      nodes.push(rootNode);



      const layers = 6;

      const maxRadius = 30;

      const nodesPerLayer = Math.floor(35 * config.densityFactor);

      for (let layer = 1; layer <= layers; layer++) {

        const radius = maxRadius * (layer / layers);

        const layerNodes = [];

        for (let i = 0; i < nodesPerLayer; i++) {

          const theta = (i / nodesPerLayer) * Math.PI * 2;

          const pos = new THREE.Vector3(radius * Math.cos(theta), 0, radius * Math.sin(theta))

            .add(new THREE.Vector3(

              THREE.MathUtils.randFloatSpread(2),

              THREE.MathUtils.randFloatSpread(2),

              THREE.MathUtils.randFloatSpread(2)

            ));

          const newNode = new Node(pos, layer, Math.random() < 0.6 ? 1 : 0);

          newNode.distanceFromRoot = radius;

          nodes.push(newNode);

          layerNodes.push(newNode);



          if (layer === 1) rootNode.addConnection(newNode, 0.95);

          const nextIdx = (i + 1) % nodesPerLayer;

          const nextPos = new THREE.Vector3(

            radius * Math.cos(((nextIdx / nodesPerLayer) * Math.PI * 2)),

            0,

            radius * Math.sin(((nextIdx / nodesPerLayer) * Math.PI * 2))

          );

          const nextNode = layerNodes[nextIdx] || nodes.find(n => n.level === layer && n.position.distanceTo(nextPos) < 4);

          if (nextNode) newNode.addConnection(nextNode, 0.75);

        }

        if (layer > 1) {

          const prev = nodes.filter(n => n.level === layer - 1);

          nodes.filter(n => n.level === layer).forEach(curr => {

            const closest = prev.reduce((best, p) => {

              const d = p.position.distanceTo(curr.position);

              return d < best.d ? { node: p, d } : best;

            }, { node: null, d: Infinity }).node;

            if (closest) curr.addConnection(closest, 0.85);

          });

        }

      }



      embellishSacredGeometry(nodes, config.densityFactor, true);

      nodes[0].formationIndex = 2;

      return { nodes, rootNode };

    }



    function generateBlackHole() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.5;

      nodes.push(rootNode);



      const rings = 8;

      const maxRadius = 35;

      const nodesPerRing = Math.floor(30 * config.densityFactor);

      for (let r = 1; r <= rings; r++) {

        const radius = maxRadius * (r / rings) * (0.7 + Math.random() * 0.3);

        const ringNodes = [];

        for (let i = 0; i < nodesPerRing; i++) {

          const theta = (i / nodesPerRing) * Math.PI * 2 + Math.random() * 0.4;

          const pos = new THREE.Vector3(radius * Math.cos(theta), THREE.MathUtils.randFloatSpread(3), radius * Math.sin(theta));

          const newNode = new Node(pos, r, Math.random() < 0.7 ? 1 : 0);

          newNode.distanceFromRoot = radius;

          nodes.push(newNode);

          ringNodes.push(newNode);



          if (r === 1) rootNode.addConnection(newNode, 0.95);

          if (Math.random() < 0.5 * config.densityFactor) {

            const randomNode = nodes[Math.floor(Math.random() * nodes.length)];

            if (randomNode !== newNode) newNode.addConnection(randomNode, 0.65);

          }

        }

        for (let i = 0; i < ringNodes.length; i++) {

          ringNodes[i].addConnection(ringNodes[(i + 1) % ringNodes.length], 0.8);

        }

        if (r > 1) {

          const prev = nodes.filter(n => n.level === r - 1);

          ringNodes.forEach(curr => {

            const closest = prev.reduce((best, p) => {

              const d = p.position.distanceTo(curr.position);

              return d < best.d ? { node: p, d } : best;

            }, { node: null, d: Infinity }).node;

            if (closest) curr.addConnection(closest, 0.85);

          });

        }

      }



      embellishSacredGeometry(nodes, config.densityFactor, true);

      nodes[0].formationIndex = 3;

      return { nodes, rootNode };

    }



    // Metatron

    function generateMetatron() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.2;

      nodes.push(rootNode);



      const S = 10;

      const cube = [

        [-S,-S,-S],[ S,-S,-S],[ S, S,-S],[-S, S,-S],

        [-S,-S, S],[ S,-S, S],[ S, S, S],[-S, S, S]

      ];

      const oct = [[0,0,-S*1.4],[0,0,S*1.4],[-S*1.4,0,0],[S*1.4,0,0],[0,-S*1.4,0],[0,S*1.4,0]];

      const t = S*1.15;

      const tetra = [[ t, t, t], [ t,-t,-t], [-t, t,-t], [-t,-t, t]];

      const pts = [...cube, ...oct, ...tetra];



      const verts = pts.map(p => {

        const pos = new THREE.Vector3(p[0], p[1], p[2]).add(new THREE.Vector3(

          THREE.MathUtils.randFloatSpread(0.8),

          THREE.MathUtils.randFloatSpread(0.8),

          THREE.MathUtils.randFloatSpread(0.8)

        ));

        const n = new Node(pos, 1, Math.random() < 0.5 ? 1 : 0);

        n.distanceFromRoot = pos.length();

        nodes.push(n);

        return n;

      });



      rootNode.addConnection(verts[0], 1.0);

      for (let i = 0; i < verts.length; i++) {

        for (let j = i + 1; j < verts.length; j++) {

          const d = verts[i].position.distanceTo(verts[j].position);

          const s = d < S*1.6 ? 0.95 : d < S*2.2 ? 0.8 : (Math.random() < 0.1 ? 0.6 : 0);

          if (s > 0) verts[i].addConnection(verts[j], s);

        }

      }



      embellishSacredGeometry(nodes, config.densityFactor, true);

      nodes[0].formationIndex = 4;

      return { nodes, rootNode };

    }



    // Flower of Life

    function generateFlowerOfLife() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.0;

      nodes.push(rootNode);



      const radius = 6;

      const layers = 4;

      const jitter = 0.9;

      const ringNodes = [];



      const center = new Node(new THREE.Vector3(0, 0, 0), 1, 0);

      center.distanceFromRoot = 0;

      nodes.push(center);

      ringNodes.push(center);

      rootNode.addConnection(center, 1.0);



      for (let layer = 1; layer <= layers; layer++) {

        const count = layer * 6;

        for (let i = 0; i < count; i++) {

          const ang = (i / count) * Math.PI * 2;

          const r = layer * radius;

          const x = r * Math.cos(ang);

          const z = r * Math.sin(ang);

          const y = THREE.MathUtils.randFloatSpread(1.5);

          const pos = new THREE.Vector3(x, y, z).add(new THREE.Vector3(

            THREE.MathUtils.randFloatSpread(jitter),

            THREE.MathUtils.randFloatSpread(jitter),

            THREE.MathUtils.randFloatSpread(jitter)

          ));

          const n = new Node(pos, layer, Math.random() < 0.6 ? 1 : 0);

          n.distanceFromRoot = Math.sqrt(x*x + y*y + z*z);

          nodes.push(n);

          ringNodes.push(n);

        }

      }



      for (let i = 0; i < ringNodes.length; i++) {

        const a = ringNodes[i];

        const nearest = nodes

          .filter(b => b !== a)

          .map(b => ({ b, d: a.position.distanceTo(b.position) }))

          .sort((u, v) => u.d - v.d)

          .slice(0, 6 + Math.floor(2 * config.densityFactor));

        nearest.forEach(({ b }, idx) => a.addConnection(b, idx === 0 ? 0.95 : 0.75));

      }



      embellishSacredGeometry(nodes, config.densityFactor, true);

      nodes[0].formationIndex = 5;

      return { nodes, rootNode };

    }



    // Torus Knot (p=2, q=3)

    function generateTorusKnot() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.3;

      nodes.push(rootNode);



      const p = 2, q = 3;

      const R = 16, r = 6;

      const N = Math.floor(360 * config.densityFactor) + 240;



      const ringNodes = [];

      for (let i = 0; i < N; i++) {

        const t = i / N * Math.PI * 2;

        const x = (R + r * Math.cos(q * t)) * Math.cos(p * t);

        const y = (R + r * Math.cos(q * t)) * Math.sin(p * t);

        const z = r * Math.sin(q * t);

        const pos = new THREE.Vector3(x, z, y).add(new THREE.Vector3(

          THREE.MathUtils.randFloatSpread(1.2),

          THREE.MathUtils.randFloatSpread(1.2),

          THREE.MathUtils.randFloatSpread(1.2)

        ));



        const n = new Node(pos, 1 + Math.floor((i / N) * 8), Math.random() < 0.55 ? 1 : 0);

        n.distanceFromRoot = pos.length();

        nodes.push(n);

        ringNodes.push(n);

      }



      rootNode.addConnection(ringNodes[0], 0.95);

      for (let i = 0; i < ringNodes.length; i++) {

        ringNodes[i].addConnection(ringNodes[(i + 1) % ringNodes.length], 0.92);

        if (i % 5 === 0) ringNodes[i].addConnection(ringNodes[(i + 10) % ringNodes.length], 0.75);

      }



      embellishSacredGeometry(nodes, config.densityFactor, true);

      nodes[0].formationIndex = 6;

      return { nodes, rootNode };

    }



    // Moving spiral (only spiral kept)

    function generateMovingSpiral() {

      const nodes = [];

      const rootNode = new Node(new THREE.Vector3(0, 0, 0), 0, 0);

      rootNode.size = 2.2;

      nodes.push(rootNode);



      const numSpirals = 8;

      const totalHeight = 45;

      const maxRadius = 22;

      const nodesPerSpiral = Math.floor(45 * config.densityFactor);

      const spiralNodes = [];

      for (let s = 0; s < numSpirals; s++) {

        const spiralPhase = (s / numSpirals) * Math.PI * 2;

        const spiralArray = [];

        for (let i = 0; i < nodesPerSpiral; i++) {

          const t = i / (nodesPerSpiral - 1);

          const height = (t - 0.5) * totalHeight;

          const radius = maxRadius * Math.sin(t * Math.PI);

          const angle = spiralPhase + t * Math.PI * 2 * 3;

          const pos = new THREE.Vector3(radius * Math.cos(angle), height, radius * Math.sin(angle))

            .add(new THREE.Vector3(

              THREE.MathUtils.randFloatSpread(2),

              THREE.MathUtils.randFloatSpread(2),

              THREE.MathUtils.randFloatSpread(2)

            ));

          const level = Math.floor(t * 6) + 1;

          const newNode = new Node(pos, level, (Math.random() < 0.5 || i > nodesPerSpiral - 3) ? 1 : 0);

          newNode.distanceFromRoot = Math.sqrt(radius * radius + height * height);

          newNode.spiralIndex = s;

          newNode.spiralPosition = t;

          newNode.baseAngle = angle;

          nodes.push(newNode);

          spiralArray.push(newNode);

        }

        spiralNodes.push(spiralArray);

      }

      for (const spiral of spiralNodes) {

        rootNode.addConnection(spiral[0], 1.0);

        for (let i = 0; i < spiral.length - 1; i++) {

          spiral[i].addConnection(spiral[i + 1], 0.95);

        }

      }

      for (let s = 0; s < numSpirals; s++) {

        const currentSpiral = spiralNodes[s];

        const nextSpiral = spiralNodes[(s + 1) % numSpirals];

        const connectionPoints = 8;

        for (let c = 0; c < connectionPoints; c++) {

          const t = c / (connectionPoints - 1);

          const idx1 = Math.floor(t * (currentSpiral.length - 1));

          const idx2 = Math.floor(t * (nextSpiral.length - 1));

          currentSpiral[idx1].addConnection(nextSpiral[idx2], 0.85);

        }

      }

      // keep embellishments minimal for animated set (no micro nodes)

      embellishSacredGeometry(nodes, config.densityFactor, false);



      nodes[0].formationIndex = 7;

      return { nodes, rootNode };

    }



    function generateNeuralNetwork(formationIndex, densityFactor = 1.0) {

      const idx = formationIndex % config.numFormations;

      switch (idx) {

        case 0: return generateWireframeCube();

        case 1: return generateDoubleHelix();

        case 2: return generateMandalas();

        case 3: return generateBlackHole();

        case 4: return generateMetatron();

        case 5: return generateFlowerOfLife();

        case 6: return generateTorusKnot();

        case 7: return generateMovingSpiral();

      }

      return generateWireframeCube();

    }



    // Build a THREE.Group from a network (nodes + connections)

    function buildGroupFromNetwork(network) {

      const group = new THREE.Group();



      // Nodes geometry

      const nodePositions = [];

      const nodeTypes = [];

      const nodeSizes = [];

      const nodeColors = [];

      const distancesFromRoot = [];



      const palette = colorPalettes[config.activePaletteIndex];



      network.nodes.forEach((node) => {

        nodePositions.push(node.position.x, node.position.y, node.position.z);

        nodeTypes.push(node.type);

        nodeSizes.push(node.size);

        distancesFromRoot.push(node.distanceFromRoot);

        const colorIndex = Math.min(node.level, palette.length - 1);

        const baseColor = palette[colorIndex % palette.length].clone();

        baseColor.offsetHSL(

          THREE.MathUtils.randFloatSpread(0.06),

          THREE.MathUtils.randFloatSpread(0.12),

          THREE.MathUtils.randFloatSpread(0.12)

        );

        nodeColors.push(baseColor.r, baseColor.g, baseColor.b);

      });



      const nodesGeometry = new THREE.BufferGeometry();

      nodesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePositions, 3));

      nodesGeometry.setAttribute('nodeType', new THREE.Float32BufferAttribute(nodeTypes, 1));

      nodesGeometry.setAttribute('nodeSize', new THREE.Float32BufferAttribute(nodeSizes, 1));

      nodesGeometry.setAttribute('nodeColor', new THREE.Float32BufferAttribute(nodeColors, 3));

      nodesGeometry.setAttribute('distanceFromRoot', new THREE.Float32BufferAttribute(distancesFromRoot, 1));



      const nodesMaterial = new THREE.ShaderMaterial({

        uniforms: THREE.UniformsUtils.clone(pulseUniforms),

        vertexShader: nodeShader.vertexShader,

        fragmentShader: nodeShader.fragmentShader,

        transparent: true,

        depthWrite: false,

        blending: THREE.AdditiveBlending

      });



      const nodesMesh = new THREE.Points(nodesGeometry, nodesMaterial);

      group.add(nodesMesh);



      // Connections geometry

      const connectionColors = [];

      const connectionStrengths = [];

      const connectionPositions = [];

      const startPoints = [];

      const endPoints = [];

      const pathIndices = [];

      const processedConnections = new Set();

      const numSegments = 20;

      let pathIndex = 0;



      network.nodes.forEach((node, nodeIndex) => {

        node.connections.forEach(connection => {

          const connectedNode = connection.node;

          const connectedIndex = network.nodes.indexOf(connectedNode);

          if (connectedIndex === -1) return;

          const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');

          if (!processedConnections.has(key)) {

            processedConnections.add(key);

            const startPoint = node.position;

            const endPoint = connectedNode.position;

            for (let i = 0; i < numSegments; i++) {

              const t = i / (numSegments - 1);

              connectionPositions.push(t, 0, 0);

              startPoints.push(startPoint.x, startPoint.y, startPoint.z);

              endPoints.push(endPoint.x, endPoint.y, endPoint.z);

              pathIndices.push(pathIndex);

              connectionStrengths.push(connection.strength);

              const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);

              const baseColor = palette[avgLevel % palette.length].clone();

              baseColor.offsetHSL(

                THREE.MathUtils.randFloatSpread(0.06),

                THREE.MathUtils.randFloatSpread(0.12),

                THREE.MathUtils.randFloatSpread(0.12)

              );

              connectionColors.push(baseColor.r, baseColor.g, baseColor.b);

            }

            pathIndex++;

          }

        });

      });



      const connectionsGeometry = new THREE.BufferGeometry();

      connectionsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(connectionPositions, 3));

      connectionsGeometry.setAttribute('startPoint', new THREE.Float32BufferAttribute(startPoints, 3));

      connectionsGeometry.setAttribute('endPoint', new THREE.Float32BufferAttribute(endPoints, 3));

      connectionsGeometry.setAttribute('connectionStrength', new THREE.Float32BufferAttribute(connectionStrengths, 1));

      connectionsGeometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));

      connectionsGeometry.setAttribute('pathIndex', new THREE.Float32BufferAttribute(pathIndices, 1));



      const connectionsMaterial = new THREE.ShaderMaterial({

        uniforms: THREE.UniformsUtils.clone(pulseUniforms),

        vertexShader: connectionShader.vertexShader,

        fragmentShader: connectionShader.fragmentShader,

        transparent: true,

        depthWrite: false,

        blending: THREE.AdditiveBlending

      });



      const connectionsMesh = new THREE.LineSegments(connectionsGeometry, connectionsMaterial);

      group.add(connectionsMesh);



      // Palette to pulse colors

      connectionsMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);

      connectionsMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);

      connectionsMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);

      nodesMaterial.uniforms.uPulseColors.value[0].copy(palette[0]);

      nodesMaterial.uniforms.uPulseColors.value[1].copy(palette[1]);

      nodesMaterial.uniforms.uPulseColors.value[2].copy(palette[2]);

      nodesMaterial.uniforms.uActivePalette.value = config.activePaletteIndex;



      return { group, nodesMesh, connectionsMesh };

    }



    // Current/next groups and networks

    let currentGroup = null, nextGroup = null;

    let currentNodesMesh = null, currentConnectionsMesh = null;

    let nextNodesMesh = null, nextConnectionsMesh = null;

    let currentNetwork = null, nextNetwork = null;



    function recolorGroup(meshes, network, paletteIndex) {

      if (!meshes || !network) return;

      const palette = colorPalettes[paletteIndex];



      // Nodes

      const nodeColorsAttr = meshes.nodesMesh.geometry.attributes.nodeColor;

      for (let i = 0; i < nodeColorsAttr.count; i++) {

        const node = network.nodes[i];

        if (!node) continue;

        const colorIndex = Math.min(node.level, palette.length - 1);

        const baseColor = palette[colorIndex % palette.length].clone();

        baseColor.offsetHSL(

          THREE.MathUtils.randFloatSpread(0.06),

          THREE.MathUtils.randFloatSpread(0.12),

          THREE.MathUtils.randFloatSpread(0.12)

        );

        nodeColorsAttr.setXYZ(i, baseColor.r, baseColor.g, baseColor.b);

      }

      nodeColorsAttr.needsUpdate = true;



      // Connections

      const connectionColors = [];

      const processedConnections = new Set();

      const numSegments = 20;

      network.nodes.forEach((node, nodeIndex) => {

        node.connections.forEach(connection => {

          const connectedNode = connection.node;

          const connectedIndex = network.nodes.indexOf(connectedNode);

          if (connectedIndex === -1) return;

          const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');

          if (!processedConnections.has(key)) {

            processedConnections.add(key);

            for (let i = 0; i < numSegments; i++) {

              const avgLevel = Math.min(Math.floor((node.level + connectedNode.level) / 2), palette.length - 1);

              const baseColor = palette[avgLevel % palette.length].clone();

              baseColor.offsetHSL(

                THREE.MathUtils.randFloatSpread(0.06),

                THREE.MathUtils.randFloatSpread(0.12),

                THREE.MathUtils.randFloatSpread(0.12)

              );

              connectionColors.push(baseColor.r, baseColor.g, baseColor.b);

            }

          }

        });

      });

      meshes.connectionsMesh.geometry.setAttribute('connectionColor', new THREE.Float32BufferAttribute(connectionColors, 3));

      meshes.connectionsMesh.geometry.attributes.connectionColor.needsUpdate = true;



      // Pulse colors

      meshes.nodesMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));

      meshes.connectionsMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));

      meshes.nodesMesh.material.uniforms.uActivePalette.value = paletteIndex;

    }



    function updateTheme(paletteIndex) {

      config.activePaletteIndex = paletteIndex;



      // Current group

      if (currentNodesMesh && currentConnectionsMesh && currentNetwork) {

        recolorGroup({nodesMesh: currentNodesMesh, connectionsMesh: currentConnectionsMesh}, currentNetwork, paletteIndex);

      }

      // Next group, if transitioning

      if (nextNodesMesh && nextConnectionsMesh && nextNetwork) {

        recolorGroup({nodesMesh: nextNodesMesh, connectionsMesh: nextConnectionsMesh}, nextNetwork, paletteIndex);

      }



      // Starfield colors

      const palette = colorPalettes[paletteIndex];

      const starColors = starfield.points.geometry.attributes.color;

      for (let i = 0; i < starColors.count; i++) {

        const color = palette[Math.floor(Math.random() * palette.length)].clone();

        color.offsetHSL(THREE.MathUtils.randFloatSpread(0.15), THREE.MathUtils.randFloatSpread(0.3), THREE.MathUtils.randFloatSpread(0.3));

        starColors.setXYZ(i, color.r, color.g, color.b);

      }

      starColors.needsUpdate = true;



      // Shooting stars color

      starfield.shootingStars.forEach(star => {

        star.line.material.color.copy(palette[Math.floor(Math.random() * palette.length)]);

      });

    }



    function createNetworkVisualization(formationIndex, densityFactor = 1.0, transition = true) {

      config.currentFormation = formationIndex;

      document.getElementById('formation-label').textContent = config.formationNames[formationIndex];



      const newNetwork = generateNeuralNetwork(formationIndex, densityFactor);

      if (!newNetwork || newNetwork.nodes.length === 0) return;



      const built = buildGroupFromNetwork(newNetwork);

      const palette = colorPalettes[config.activePaletteIndex];

      built.nodesMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));

      built.connectionsMesh.material.uniforms.uPulseColors.value.forEach((c, i) => c.copy(palette[i % palette.length]));

      built.nodesMesh.material.uniforms.uActivePalette.value = config.activePaletteIndex;



      if (!transition || !currentGroup) {

        if (currentGroup) {

          scene.remove(currentGroup);

        }

        currentGroup = built.group;

        currentNodesMesh = built.nodesMesh;

        currentConnectionsMesh = built.connectionsMesh;

        currentNetwork = newNetwork;

        currentNodesMesh.material.uniforms.uGlobalOpacity.value = 1.0;

        currentConnectionsMesh.material.uniforms.uGlobalOpacity.value = 1.0;

        scene.add(currentGroup);

        return;

      }



      // Cross-fade transition

      nextGroup = built.group;

      nextNodesMesh = built.nodesMesh;

      nextConnectionsMesh = built.connectionsMesh;

      nextNetwork = newNetwork;



      nextNodesMesh.material.uniforms.uGlobalOpacity.value = 0.0;

      nextConnectionsMesh.material.uniforms.uGlobalOpacity.value = 0.0;

      nextGroup.scale.set(0.9, 0.9, 0.9);

      scene.add(nextGroup);



      config.isTransitioning = true;

      config.transitionProgress = 0;

    }



    // Interaction helpers

    const raycaster = new THREE.Raycaster();

    const pointer = new THREE.Vector2();

    const interactionPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

    const interactionPoint = new THREE.Vector3();

    let lastPulseIndex = 0;

    function setPulseOnMeshes(meshes, point, time) {

      if (!meshes) return;

      const { nodesMesh, connectionsMesh } = meshes;

      if (!nodesMesh || !connectionsMesh) return;

      lastPulseIndex = (lastPulseIndex + 1) % 3;

      nodesMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(point);

      nodesMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;

      connectionsMesh.material.uniforms.uPulsePositions.value[lastPulseIndex].copy(point);

      connectionsMesh.material.uniforms.uPulseTimes.value[lastPulseIndex] = time;

      const palette = colorPalettes[config.activePaletteIndex];

      const randomColor = palette[Math.floor(Math.random() * palette.length)];

      nodesMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);

      connectionsMesh.material.uniforms.uPulseColors.value[lastPulseIndex].copy(randomColor);

    }



    function triggerPulse(clientX, clientY) {

      started = true;

      pointer.x = (clientX / window.innerWidth) * 2 - 1;

      pointer.y = -(clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);

      interactionPlane.normal.copy(camera.position).normalize();

      interactionPlane.constant = -interactionPlane.normal.dot(camera.position) + camera.position.length() * 0.5;

      if (raycaster.ray.intersectPlane(interactionPlane, interactionPoint)) {

        const time = clock.getElapsedTime();

        // Current group

        if (currentNodesMesh && currentConnectionsMesh) {

          setPulseOnMeshes({nodesMesh: currentNodesMesh, connectionsMesh: currentConnectionsMesh}, interactionPoint, time);

        }

        // Next group (during transition)

        if (nextNodesMesh && nextConnectionsMesh) {

          setPulseOnMeshes({nodesMesh: nextNodesMesh, connectionsMesh: nextConnectionsMesh}, interactionPoint, time);

        }

        waves.push(new Wave(clientX * render.dpi, clientY * render.dpi));

      }

    }



    renderer.domElement.addEventListener('click', (e) => {

      if (e.target.closest('.ui-panel')) return;

      triggerPulse(e.clientX, e.clientY);

    });

    renderer.domElement.addEventListener('touchstart', (e) => {

      if (e.target.closest('.ui-panel')) return;

      e.preventDefault();

      if (e.touches.length === 1) triggerPulse(e.touches[0].clientX, e.touches[0].clientY);

    }, { passive: false });



    // Swipe formations

    let touchStartX = 0;

    renderer.domElement.addEventListener('touchstart', (e) => {

      if (e.target.closest('.ui-panel')) return;

      if (e.touches.length === 1) touchStartX = e.touches[0].clientX;

    }, { passive: false });

    renderer.domElement.addEventListener('touchend', (e) => {

      if (e.target.closest('.ui-panel')) return;

      if (e.changedTouches.length === 1 && !config.isTransitioning) {

        const touchEndX = e.changedTouches[0].clientX;

        const deltaX = touchEndX - touchStartX;

        if (Math.abs(deltaX) > 100) {

          const newFormation = deltaX > 0 ?

            (config.currentFormation + 1) % config.numFormations :

            (config.currentFormation - 1 + config.numFormations) % config.numFormations;

          createNetworkVisualization(newFormation, config.densityFactor, true);

          controls.autoRotate = false;

          setTimeout(() => { controls.autoRotate = true; }, 4000);

        }

      }

    }, { passive: false });



    document.addEventListener('keydown', (e) => {

      if (e.target.closest('.ui-panel')) return;

      if (!config.isTransitioning) {

        if (e.key === '1') {

          const newFormation = (config.currentFormation - 1 + config.numFormations) % config.numFormations;

          createNetworkVisualization(newFormation, config.densityFactor, true);

          controls.autoRotate = false;

          setTimeout(() => { controls.autoRotate = true; }, 4000);

        } else if (e.key === '2') {

          const newFormation = (config.currentFormation + 1) % config.numFormations;

          createNetworkVisualization(newFormation, config.densityFactor, true);

          controls.autoRotate = false;

          setTimeout(() => { controls.autoRotate = true; }, 4000);

        }

      }

    });



    window.addEventListener('deviceorientation', (e) => {

      if (e.beta !== null && Math.abs(e.beta) > 60) {

        controls.reset();

        controls.autoRotate = false;

        setTimeout(() => { controls.autoRotate = true; }, 2000);

      }

    });



    const themeButtons = document.querySelectorAll('.theme-button');

    themeButtons.forEach(btn => {

      btn.addEventListener('click', (e) => {

        e.stopPropagation();

        const idx = parseInt(btn.dataset.theme, 10);

        themeButtons.forEach(b => b.classList.remove('active'));

        btn.classList.add('active');

        updateTheme(idx);

      });

    });



    const densitySlider = document.getElementById('density-slider');

    const densityValue = document.getElementById('density-value');

    let densityTimeout;

    densitySlider.addEventListener('input', () => {

      const val = parseInt(densitySlider.value, 10);

      config.densityFactor = val / 100;

      densityValue.textContent = `${val}%`;

      clearTimeout(densityTimeout);

      densityTimeout = setTimeout(() => {

        // Rebuild immediately without cross-fade

        createNetworkVisualization(config.currentFormation, config.densityFactor, false);

        updateTheme(config.activePaletteIndex);

      }, 300);

    });



    const clock = new THREE.Clock();



    function animate() {

      requestAnimationFrame(animate);

      const t = clock.getElapsedTime();



      // Transition cross-fade

      if (config.isTransitioning && currentGroup && nextGroup) {

        config.transitionProgress += 1 / (config.transitionDuration * 60);

        const eased = easingUtils.easeInOutCubic(Math.min(1, config.transitionProgress));



        // Update uniforms for time/breathe on both groups

        if (currentNodesMesh && currentConnectionsMesh) {

          currentNodesMesh.material.uniforms.uBreatheScale.value = config.breatheScale;

          currentNodesMesh.material.uniforms.uTime.value = t;

          currentConnectionsMesh.material.uniforms.uBreatheScale.value = config.breatheScale;

          currentConnectionsMesh.material.uniforms.uTime.value = t;

        }

        if (nextNodesMesh && nextConnectionsMesh) {

          nextNodesMesh.material.uniforms.uBreatheScale.value = config.breatheScale;

          nextNodesMesh.material.uniforms.uTime.value = t;

          nextConnectionsMesh.material.uniforms.uBreatheScale.value = config.breatheScale;

          nextConnectionsMesh.material.uniforms.uTime.value = t;

        }



        // Fade out old, fade in new, add subtle scale/rotation

        currentNodesMesh.material.uniforms.uGlobalOpacity.value = 1.0 - eased;

        currentConnectionsMesh.material.uniforms.uGlobalOpacity.value = 1.0 - eased;



        nextNodesMesh.material.uniforms.uGlobalOpacity.value = eased;

        nextConnectionsMesh.material.uniforms.uGlobalOpacity.value = eased;



        currentGroup.scale.set(1 + 0.05 * (1 - eased), 1 + 0.05 * (1 - eased), 1 + 0.05 * (1 - eased));

        currentGroup.rotation.y += 0.003 * (1 - eased);

        nextGroup.scale.set(0.9 + 0.1 * eased, 0.9 + 0.1 * eased, 0.9 + 0.1 * eased);



        if (eased >= 1) {

          scene.remove(currentGroup);

          currentGroup = nextGroup;

          currentNodesMesh = nextNodesMesh;

          currentConnectionsMesh = nextConnectionsMesh;

          currentNetwork = nextNetwork;



          nextGroup = null;

          nextNodesMesh = null;

          nextConnectionsMesh = null;

          nextNetwork = null;



          config.isTransitioning = false;

          config.transitionProgress = 0;

        }

      }



      // Breathe

      config.breatheScale = 1.0 + 0.05 * Math.sin(t * 0.8);

      if (currentNodesMesh && currentConnectionsMesh) {

        currentNodesMesh.material.uniforms.uBreatheScale.value = config.breatheScale;

        currentConnectionsMesh.material.uniforms.uBreatheScale.value = config.breatheScale;

        currentNodesMesh.material.uniforms.uTime.value = t;

        currentConnectionsMesh.material.uniforms.uTime.value = t;

      }



      // Moving spiral animation (only on current group)

      if (currentNetwork && currentNetwork.nodes[0].formationIndex === 7 && currentNodesMesh && currentConnectionsMesh) {

        const nodePositions = currentNodesMesh.geometry.attributes.position.array;

        currentNetwork.nodes.forEach((node, i) => {

          if (i === 0) return; // root

          const angle = (node.baseAngle || 0) + t * 0.2;

          const radius = 22 * Math.sin((node.spiralPosition || 0) * Math.PI);

          const height = ((node.spiralPosition || 0) - 0.5) * 45;

          node.position.set(radius * Math.cos(angle), height, radius * Math.sin(angle));

          nodePositions[i * 3] = node.position.x;

          nodePositions[i * 3 + 1] = node.position.y;

          nodePositions[i * 3 + 2] = node.position.z;

        });

        currentNodesMesh.geometry.attributes.position.needsUpdate = true;



        // Update connections to match new positions

        let connIndex = 0;

        const processedConnections = new Set();

        const numSegments = 20;

        currentNetwork.nodes.forEach((node, nodeIndex) => {

          node.connections.forEach(connection => {

            const connectedNode = connection.node;

            const connectedIndex = currentNetwork.nodes.indexOf(connectedNode);

            if (connectedIndex === -1) return;

            const key = [Math.min(nodeIndex, connectedIndex), Math.max(nodeIndex, connectedIndex)].join('-');

            if (!processedConnections.has(key)) {

              processedConnections.add(key);

              const startNode = currentNetwork.nodes[nodeIndex];

              const endNode = currentNetwork.nodes[connectedIndex];

              for (let i = 0; i < numSegments; i++) {

                currentConnectionsMesh.geometry.attributes.startPoint.array[connIndex * 3] = startNode.position.x;

                currentConnectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 1] = startNode.position.y;

                currentConnectionsMesh.geometry.attributes.startPoint.array[connIndex * 3 + 2] = startNode.position.z;

                currentConnectionsMesh.geometry.attributes.endPoint.array[connIndex * 3] = endNode.position.x;

                currentConnectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 1] = endNode.position.y;

                currentConnectionsMesh.geometry.attributes.endPoint.array[connIndex * 3 + 2] = endNode.position.z;

                connIndex++;

              }

            }

          });

        });

        currentConnectionsMesh.geometry.attributes.startPoint.needsUpdate = true;

        currentConnectionsMesh.geometry.attributes.endPoint.needsUpdate = true;

      }



      // Starfield motion

      const posArr = starfield.points.geometry.attributes.position.array;

      const velArr = starfield.points.geometry.attributes.velocity.array;

      for (let i = 0; i < posArr.length; i++) {

        posArr[i] += velArr[i] * 0.1;

        if (Math.abs(posArr[i]) > 200) posArr[i] *= -0.5;

      }

      starfield.points.geometry.attributes.position.needsUpdate = true;



      // Shooting stars

      starfield.shootingStars = starfield.shootingStars.filter(star => star.life > 0);

      if (Math.random() < 0.02) {

        const newStar = createShootingStar();

        scene.add(newStar.line);

        starfield.shootingStars.push(newStar);

      }

      starfield.shootingStars.forEach(star => {

        const positions = star.line.geometry.attributes.position.array;

        star.life -= 0.016;

        star.line.material.opacity = star.life / 2.5;

        for (let i = 0; i < 2; i++) {

          positions[i * 3] += star.direction.x * 5;

          positions[i * 3 + 1] += star.direction.y * 5;

          positions[i * 3 + 2] += star.direction.z * 5;

        }

        star.line.geometry.attributes.position.needsUpdate = true;

        if (star.life <= 0) {

          scene.remove(star.line);

          star.line.geometry.dispose();

          star.line.material.dispose();

        }

      });



      controls.update();



      // Ripples overlay

      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

      waves.forEach(wave => { wave.update(); wave.render(); });



      composer.render();

    }



    window.addEventListener('resize', () => {

      render.width = window.innerWidth;

      render.height = window.innerHeight;

      render.dpi = window.devicePixelRatio;

      overlayCanvas.width = render.width * render.dpi;

      overlayCanvas.height = render.height * render.dpi;



      camera.aspect = render.width / render.height;

      camera.updateProjectionMatrix();

      renderer.setSize(render.width, render.height);

      composer.setSize(render.width, render.height);

    });



    // Init

    createNetworkVisualization(0, 1.0, false);

    animate();

  </script>
</body>
</html>